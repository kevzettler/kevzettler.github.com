<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>I built a multiplayer voxel browser game engine.<!-- --> - Kev Zettler</title><meta property="og:image" content="https://kevzettler.com/img/multilpayer-engine-post/meta.png"/><meta name="description" content="Intro &amp;#38; TLDR;
This post is a retrospective on a multiplayer voxel browser game engine I built. This post will cover the squishy storytelling side of the project and the accompanying code repository has all of the hard technical details. This is essentially a 2 part post. Read this and read the r"/><meta property="og:description" content="Intro &amp;#38; TLDR;
This post is a retrospective on a multiplayer voxel browser game engine I built. This post will cover the squishy storytelling side of the project and the accompanying code repository has all of the hard technical details. This is essentially a 2 part post. Read this and read the r"/><meta name="keywords" content="gamedev, javascript, react"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/616df6187075e4dc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/616df6187075e4dc.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/js/jquery-3.6.4.min.js" defer="" data-nscript="beforeInteractive"></script><script src="/js/vendor/highlight/highlight.min.js" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-3479d0a64c7ffb47.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08ad0149ddcbdd04.js" defer=""></script><script src="/_next/static/chunks/189-925753359219706e.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-e4fc806a6ecc0d48.js" defer=""></script><script src="/_next/static/ouxHwMCqjJSaphqO_humA/_buildManifest.js" defer=""></script><script src="/_next/static/ouxHwMCqjJSaphqO_humA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><div class="container"><button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="brand" href="/">Kev Zettler</a><div class="nav-collapse collapse"><ul class="nav"><li class=""><a href="/">Blog</a></li><li class=""><a href="/about">About</a></li></ul></div></div></div></div><div class="container" id="body-content"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="post cell"><h1>I built a multiplayer voxel browser game engine.</h1><h4 class="large-bottom">Posted on <!-- -->2023-04-25</h4><div class="content"><h2>Intro &amp; TLDR;</h2>
<p>This post is a retrospective on a <a href="https://github.com/kevzettler/multiplayer-voxel-browser-game-engine">multiplayer voxel browser game engine</a> I built. This post will cover the squishy storytelling side of the project and the <a href="https://github.com/kevzettler/multiplayer-voxel-browser-game-engine">accompanying code repository</a> has all of the hard technical details. This is essentially a 2 part post. Read this and read the repo README.</p>
<a href="/img/multiplayer-engine-post/play.gif">
  <img src="/img/multiplayer-engine-post/play.gif" alt="Animated give of a 3d multiplayer browser engine" title="Demonstartion of multiplayer game engine multilpe players"/>
</a><h3>Disclaimer</h3>
<p>This project is a bit old and stale at the time of this post. Some of the tech decisions made sense at during time of development but are questionable today. I will try to address that in this post. I started this project with very minimal game development experience. I had no idea how many things worked, shaders, 3d asset files, raw binary buffer manipulation, scene graphs, physics engines. I learned all these skills and more during this project. This experience also helped me later land some major corporate jobs. This project was primarily active through 2017-2019 however exploration for the project goes back to late 2016.</p>
<a href="/img/multiplayer-engine-post/disclaimer.png">
  <img src="/img/multiplayer-engine-post/disclaimer.png" alt="Should you build a custom engine? Yes." title="Should you build a custom engine? Yes" width="400"/>
</a><h2>Inspiration &amp; motivation</h2>
<p>I wanted to build a multiplayer browser game. I was very inspired by <code>.io</code> games and sites like <a href="https://iogames.space/">iogames.space</a>. I love the <code>.io</code> gaming experience of copy pasting a URL around and getting in a game with your friends. Furthermore I wanted to recreate a canceled MMO called <a href="https://en.wikipedia.org/wiki/Exteel">Exteel</a>. My background was in web development and design. I stuck with the tools and environment I was most familiar with.</p>
<h3>Target features</h3>
<ul><li>network multiplayer</li>
<li>playable cross platform in browser</li>
<li>player avatar customization</li>
<li>lazy loading assets</li>
<li>shared client &amp; server game code</li>
<li>third person camera</li>
<li>platforming physics</li>
<li>destructible environments</li>
</ul>
<p>All these features were completed except for destructible environments. Destructible environments was a big driver for the voxel asset pipeline, assuming voxels would enable the destructibility. This idea was inspired by another browser game <a href="https://github.com/Lallassu/VoxLords">VoxLords</a> which had good environmental destruction and captured my imagination. I actually started this out by forking and modifying VoxLords to be multiplayer.</p>
<p><a href="https://twitter.com/lallassu/status/725401257377169409?s=20">https://twitter.com/lallassu/status/725401257377169409?s=20</a></p>
<p>After hacking on VoxLords it was clear that it was entirely possible to make a captivating 3D multiplayer browser experience. Unfortunately, Lallassu was correct and there were some major performance issues in the VoxLords engine that would require extensive refactoring. I decided to start a fresh project.</p>
<h4>Why I didn&#x27;t use one of the mega corp engines</h4>
<p>I was not happy with Unity and Unreal&#x27;s HTML5 browser experience. Unity&#x27;s HTML5 export creates a giant asset bundle that users have to sit and watch a loading bar before playing. This was against my goals of lazy loading assets on demand. Additionally Unity&#x27;s multiplayer server side support was sketchy and <a href="https://radcade.com/unity-multiplayer-netcode-for-gameobjects/">still is</a>. Unreal had much stronger multiplayer support but similar issues with browser builds and in addition Unreal itself was too large to install on my laptop.</p>
<h2>The work</h2>
<p>After hacking the VoxLords multiplayer fork. I started by exploring multiple tech stacks concurrently and building a prototype in each of them. The stacks I looked at were Babylon.js, three.js, &amp; Stackgl.</p>
<h3>Tech stack requirements</h3>
<p>The first requirement was support for the 3d asset pipeline. I had been working with voxel models in <a href="https://ephtracy.github.io/">MagicaVoxel .vox</a> format. This was great for static entities. There&#x27;s primarily 2 ways to animate a voxel model. You can create frame based animation, in which you each frame of the animation is a separate voxel animation and then you morph or swap them out on at runtime. Or you can apply skeletal transformation data to voxel meshes. If you decide on the skeletal route you need to break the voxel mesh up into smaller mesh&#x27;s that correspond to the skeleton bones.</p>
<p>I had a character mesh that I wanted to use in .vox format but at the time MagicaVoxel did not support multiple meshes. I converted the .vox file to <a href="https://www.getqubicle.com/">quiblce .qb</a> file and broke the character up into separate meshes.</p>
<a href="/img/multiplayer-engine-post/qubicle.png">
  <img src="/img/multiplayer-engine-post/qubicle.png" alt="Qubicle UI breaking a mesh up" title="Using Qubicle to break up a mesh for skeletal animation"/>
</a><p>The segmented qubicle mesh was then imported into Blender and animations were built in blender.</p>
<a href="/img/multiplayer-engine-post/blender.gif">
  <img src="/img/multiplayer-engine-post/blender.gif" alt="Blender skeletal walking animation" title="voxel model animated in blender with skeletal animation"/>
</a><p>The animation data and voxel meshes data was combined at runtime in the engine.</p>
<p><a href="https://twitter.com/kevzettler/status/1002235365246222336?s=20">https://twitter.com/kevzettler/status/1002235365246222336?s=20</a></p>
<h3>Tech stack evaluation</h3>
<ul><li><a href="https://threejs.org/">three.js</a><p>VoxLords was built in Three.js so I looked at it first. The Three.js - Blender pipeline was broken and could not get skeletal animation imports working. A colleague of mine who was working on a Three.js project captured some of the <a href="https://gist.github.com/AndrewRayCode/746be166c3008a03167206aec4a46531"> three.js blender exporter issues</a> at the time. This was a deal breaker for me.</p>
<p>Furthermore, Three.js did not have a good headless server side offering. Three.js uses custom math libraries that were not easily extract-able from the rendering code. This meant multiplayer support would take a lot of extra duplicate work, re-implementing the game logic on the server. Three.js has advanced significantly since then, I don&#x27;t think these are issues anymore.</p>
</li>
<li><a href="https://www.babylonjs.com/">babylon.js</a><p>I made some immediate promising progress in Babylon.js. The asset pipeline was robust and supported skeletal animation data. Babylon has camera and physics out of the box. The Babylon team and  community was super responsive and supportive. I hit a wall with Babylon.js when trying to build out the multiplayer server. Like Three.js, Babylon.js had no headless mode. Again, this meant that building multiplayer would require duplicate work reproducing all the simulation logic and physics in the server side codebase. Recent versions of Babylon have a robust headless mode and have decoupled the framework into smaller libraries. These days Three.js is king of the normie browser 3d mind share lexicon but I still find Babylon.js a much better offering.</p>
</li>
<li><a href="http://stack.gl/">stackgl</a><p>Stackgl is the dark-horse of this list. Stackgl is not trying to be a complete 3D engine like Three.js and Babylon.js. Stackgl is an ecosystem of small functional tools that can be composed to create 3d browser experiences. Stackgl follows the unix philosophy of &quot;small sharp tools&quot;. Stackgl has some main pillars: Rendering, Math, and Data. Stackgl handles rendering by focusing on direct shader code. Babylon.js and Three.js try to heavily abstract shaders away. Stackgl&#x27;s primary rendering module is <a href="http://regl.party/">Regl</a> which provides a completely novel stateless rendering pattern. Stackgl then provides many small functional math modules for dealing with vertex and geometry data. I was quickly more productive in Stackgl than the previous two stacks.</p>
<p>The modular nature made it very easy to share code between the client and server, easy to optimize performance and rendering, and easy to add custom functionality. For example Babylon.js and Three.js have their own vector math implementation libraries. Then if you use a physics engine with the physics engines have their own intern vector math libraries. furthermore if you use a multiplayer server you will need a vector math library there as well.</p>
</li>
</ul>
In Babylon and Three it becomes a lot of fake work converting and serializing between different vector implementations. In Stackgl you can easily use the same <a href="https://glmatrix.net/">gl-matrix vector math library</a> across a project which is a huge productivity gain.<a href="/img/multiplayer-engine-post/engines.png">
  <img src="/img/multiplayer-engine-post/engines.png" alt="Screenshotf of github showing multiple game engines" title="Which 3d browser engine is best?"/>
</a><p><b>When I started making progress with Stackgl I took a year off and worked on it full time throughout 2017.</b></p>
<h2>What went wrong</h2>
<p>Unfortunately, I consider this project unfinished. I did not ship a complete game experience and there are some issues with the engine that would be risky for production deployment. I&#x27;m writing this post to put closure on the project before moving on to new work and in the hopes that this experience may be useful to any others interested in this space.</p>
<h4>React vs Vanilla Js</h4>
<p>Most my web development experience has been with the React framework and I thought it would be complementary to Regl and the stack.gl ecosystem&#x27;s functional paradigm. I created a <a href="https://github.com/kevzettler/react-regl">react reconciler to bridge react and regl</a>. I started using a React stack with Redux to manage all the game state and state transitions. This React+Redux combo turned out to be a huge boon when writing UI. Game developers in traditional engines constantly complain about UI being their least favorite task. This is because game engines use traditional 2-way mutable state management UI code that is error prone and brittle. Web developers have solved these UI complaints and built tools like React that make building UI&#x27;s easy.</p>
<a href="/img/multiplayer-engine-post/react.gif">
  <img src="/img/multiplayer-engine-post/react.gif" alt="animated gif of a React 3d browser UI" title="React 3d player avatar creation system" width="400"/>
</a><p>React+Redux setup was too much performance overhead for the real time game play section. The state updates through the Redux action reducer pipeline, combined with the minimal React render updates was enough to cause noticeable hiccups in the game play frame rate. Performance in the browser environment is very sensitive to garbage collector management. In order to minimize garbage collector hits you need to use object pooling. Object pooling is a mutable state management pattern in which you pre-allocate a pool of objects that will be mutated during the life of the program to minimize runtime memory allocations. This object pooling pattern conflicts with the immutable update patterns React and Redux are built upon. Hitting these performance issues was a big roadblock and essentially became a &#x27;rewrite&#x27; in which had to rewrite the game state management to be performance optimized. This was costly and took a lot of time.</p>
<h4>Hobby time</h4>
<p>When I started making progress with Stackgl I took a year off and worked on it full time throughout 2017. I lived off some savings and unemployment checks until late 2018 I got back into corporate wage slavery from 2018-2020. A highlight during this time was I got invited to Animecon 2019 indie developer section to shill my game in the Indie game section.</p>
<a href="/img/multiplayer-engine-post/animecon.png">
  <img src="/img/multiplayer-engine-post/animecon.png" alt="A photo of me at animecon 2019 " title="Playing a game with a 2B cosplayer at animecon 2019"/>
</a><p>During this time I switched to hobby mode started putting less and less time into development I was maybe averaging 4 hours a week. I was distracted by day job work. This time shortage slowed development progress. Development picked up during 2020 Covid lockdowns unfortunately getting back into development after a hiatus presented some new challenges...</p>
<h5>Software entropy</h5>
The JavaScript ecosystem is known for moving incredibly fast. When I got back into development I spent a lot of time fighting severe software entropy. Getting the project to build with latest dependency chains of Node+NPM+webpack etc took a lot of work. The animation pipeline using Landon had severe entropy. The Landon was a mix of Rust, JavaScript and Blender versions that were not strictly pinned. I had to do work to upgrade to the latest Blender export versions but then write backwards compatibility translation layers for the animation data. I upgraded my laptop to an M1 Mac. This triggered a roadblock on the project because the WebRTC module I was using would not compile on the new M1 apple silicon chip. This has since been resolved but was pretty much the show stopper.<h2>Byproducts</h2>
<p>The work put into this project spun-off some useful libraries that I have open sourced and put on github</p>
<ul><li><a href="https://github.com/kevzettler/react-regl">react-regl</a><p>A react reconciler to bridge react and regl</p>
</li>
<li><a href="https://github.com/kevzettler/parse-magica-voxel">parse-magica-voxel</a><p>A JavaScript parser for the magicavoxel .vox binary file format</p>
</li>
<li><a href="https://github.com/kevzettler/parse-qubicle">parse-quibicle</a><p>A JavaScript parser for the .qb binary file format.</p>
</li>
<li><a href="https://github.com/kevzettler/gl-swept-sphere-triangle">gl-swept-sphere-triangle</a><p>A swept sphere to polygon collision detection algorithm</p>
</li>
</ul>
<h2>Shout outs</h2>
<p>This project was built on the work and research of other highly skilled software engineers. Without their help</p>
<ul><li><a href="https://twitter.com/MikolaLysenko">Mikola lysenko</a><p>Mikola is a primary driver of the stack.gl ecosystem and certified 10x genius developer. His blog <a href="https://0fps.net">0fps.net</a> has some mind melting content on high performance computer science, and geometry. Mikola assembled a team and basically built a Roblox clone for China in the browser. The team got together for a podcast to discuss their <a href="https://www.youtube.com/watch?v=Z_--8z549D4">Reflections on building web-based voxel MMO in China (Mikola Lysenko, et al) - YouTube</a>  It is a highly insighful talk, highly recommend if you found this post interesting.</p>
</li>
<li><a href="https://chinedufn.com/">Chinedu Francis Nwafili</a><p>Chinedu did amazing work by building the <a href="https://github.com/chinedufn/skeletal-animation-system">stackgl skeletal animation system</a> which is a key piece of the stack.gl ecosystem and this project was highly dependent on and probably couldn&#x27;t have come together without. While I was building out this project Chinedu was also building out his own game and engine we kept in correspondence while building and sharing ideas. Chinedu also built out a very cool suite of tools for Blender called <a href="https://github.com/chinedufn/landon">landon</a>. Making Blender a source of truth for game engine data. Chinedu&#x27;s blog at <a href="https://chinedufn.com/">https://chinedufn.com/</a> has in-depth development journal posts on his game engine development.</p>
</li>
<li><a href="http://www.jameswarlloyd.com/">James Warlloyd</a><p>James created the <a href="https://opengameart.org/content/voxel-mech-sniper">original mech model</a> that I used as the bases for the character art in this engine.</p>
</li>
</ul>
<h2>The state of the art</h2>
<p>Overall this project was a big educational return on investment for me. I learned about hardcore browser optimization and many other data processing techniques. I have continued to do game ( and engine ) development as a hobby and have already looked into some other emerging technologies. My focus is still on browser multiplayer experiences. I haven&#x27;t found the big engines: Unreal, Unity, Godot have the best models for multiplayer. I have previously written about <a href="https://radcade.com/how-to-add-network-multiplayer-to-your-indie-game/">multilpayer game engine design for indies</a>. The big engines have models that couple game simulation logic code to rendering code. This makes it challenging to build a server as you have to decouple the simulation and run it headless.</p>
<ul><li><a href="https://dotbigbang.com/">DotBigBang</a><p>DotBigBang is everything this project attempted to be and more. It is multiplayer voxel 3d engine all fully in the browser. DotBigBang is focused on user generated content and is essentially a multiplayer game engine. You can get a group of people together and bring your avatars into a 3D scene and then collaboratively edit and program that scene. Like a multiplayer Unity editor experience. I had the fortune to hang with the founder of DotBigBang at GDC 2023 and hear about some of the impressive browser performance optimization they were doing. He told me about forking Chromium to have better performance debugging visibility into how the JIT compilation and memory usage of the browser was working.</p>
</li>
<li><a href="https://github.com/matrix-org/thirdroom#manifold-engine">Manifold engine</a><p>The Manifold engine is a stealthy engine being developed by the <a href="https://matrix.org/">matrix.org</a> team. Its currently embedded in a repository for another project with a disclaimer they might release it in the future. The host project is called &#x27;thirdroom&#x27; and is a multilpayer VR metaverse platform.</p>
<p>When I learned about Manifold I was very excited because it has the same design philosophy and high performance computation architecture that I had been building towards. It uses Web Workers to create multiple threads to separately process rendering, physics, and networking. All the threads share memory over a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffer</a> and they use object pooling to reduce garbage collection. Manifold also has WebRTC Data channels for networking. I was able to build a promising prototype in Manifold unfortunately Manifold is tightly coupled to a matrix.org backend. The matrix backend has a clunky API to use which would make custom server side optimization challenging. If the matrix.org team ever decouples and delivers Manifold it would be very compelling option.</p>
</li>
<li><a href="https://github.com/AmbientRun/Ambient">Ambient engine</a><p>Ambient is a promising new Rust lang engine. It is a default multiplayer engine. It shares code between client and server. It compiles game code to WASM and then acts as a cross platform binary runtime to execute that WASM. I have built a promising prototype in Ambient but unfortunately Ambient does not currently build for browser environments. The Ambient team is actively working to target browsers and are aiming for an upcoming release.</p>
</li>
</ul>
</div><div><hr/><div style="overflow:hidden"><p style="float:left">If you enjoyed this article, consider following me <a href="https://www.twitter.com/kevzettler">on Twitter</a></p></div><hr/><div><h2>Comments:</h2><div id="disqus_thread"></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"I built a multiplayer voxel browser game engine.","date":"2023-04-25","contentHTML":"\u003ch2\u003eIntro \u0026#38; TLDR;\u003c/h2\u003e\n\u003cp\u003eThis post is a retrospective on a \u003ca href=\"https://github.com/kevzettler/multiplayer-voxel-browser-game-engine\"\u003emultiplayer voxel browser game engine\u003c/a\u003e I built. This post will cover the squishy storytelling side of the project and the \u003ca href=\"https://github.com/kevzettler/multiplayer-voxel-browser-game-engine\"\u003eaccompanying code repository\u003c/a\u003e has all of the hard technical details. This is essentially a 2 part post. Read this and read the repo README.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/play.gif'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/play.gif'\n       alt=\"Animated give of a 3d multiplayer browser engine\"\n       title=\"Demonstartion of multiplayer game engine multilpe players\" /\u003e\n\u003c/a\u003e\u003ch3\u003eDisclaimer\u003c/h3\u003e\n\u003cp\u003eThis project is a bit old and stale at the time of this post. Some of the tech decisions made sense at during time of development but are questionable today. I will try to address that in this post. I started this project with very minimal game development experience. I had no idea how many things worked, shaders, 3d asset files, raw binary buffer manipulation, scene graphs, physics engines. I learned all these skills and more during this project. This experience also helped me later land some major corporate jobs. This project was primarily active through 2017-2019 however exploration for the project goes back to late 2016.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/disclaimer.png'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/disclaimer.png'\n       alt=\"Should you build a custom engine? Yes.\"\n       title=\"Should you build a custom engine? Yes\" width=\"400\" /\u003e\n\u003c/a\u003e\u003ch2\u003eInspiration \u0026#38; motivation\u003c/h2\u003e\n\u003cp\u003eI wanted to build a multiplayer browser game. I was very inspired by \u003ccode\u003e.io\u003c/code\u003e games and sites like \u003ca href=\"https://iogames.space/\"\u003eiogames.space\u003c/a\u003e. I love the \u003ccode\u003e.io\u003c/code\u003e gaming experience of copy pasting a URL around and getting in a game with your friends. Furthermore I wanted to recreate a canceled MMO called \u003ca href=\"https://en.wikipedia.org/wiki/Exteel\"\u003eExteel\u003c/a\u003e. My background was in web development and design. I stuck with the tools and environment I was most familiar with.\u003c/p\u003e\n\u003ch3\u003eTarget features\u003c/h3\u003e\n\u003cul\u003e\u003cli\u003enetwork multiplayer\u003c/li\u003e\n\u003cli\u003eplayable cross platform in browser\u003c/li\u003e\n\u003cli\u003eplayer avatar customization\u003c/li\u003e\n\u003cli\u003elazy loading assets\u003c/li\u003e\n\u003cli\u003eshared client \u0026#38; server game code\u003c/li\u003e\n\u003cli\u003ethird person camera\u003c/li\u003e\n\u003cli\u003eplatforming physics\u003c/li\u003e\n\u003cli\u003edestructible environments\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAll these features were completed except for destructible environments. Destructible environments was a big driver for the voxel asset pipeline, assuming voxels would enable the destructibility. This idea was inspired by another browser game \u003ca href=\"https://github.com/Lallassu/VoxLords\"\u003eVoxLords\u003c/a\u003e which had good environmental destruction and captured my imagination. I actually started this out by forking and modifying VoxLords to be multiplayer.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://twitter.com/lallassu/status/725401257377169409?s=20\"\u003ehttps://twitter.com/lallassu/status/725401257377169409?s=20\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAfter hacking on VoxLords it was clear that it was entirely possible to make a captivating 3D multiplayer browser experience. Unfortunately, Lallassu was correct and there were some major performance issues in the VoxLords engine that would require extensive refactoring. I decided to start a fresh project.\u003c/p\u003e\n\u003ch4\u003eWhy I didn\u0026#39;t use one of the mega corp engines\u003c/h4\u003e\n\u003cp\u003eI was not happy with Unity and Unreal\u0026#39;s HTML5 browser experience. Unity\u0026#39;s HTML5 export creates a giant asset bundle that users have to sit and watch a loading bar before playing. This was against my goals of lazy loading assets on demand. Additionally Unity\u0026#39;s multiplayer server side support was sketchy and \u003ca href=\"https://radcade.com/unity-multiplayer-netcode-for-gameobjects/\"\u003estill is\u003c/a\u003e. Unreal had much stronger multiplayer support but similar issues with browser builds and in addition Unreal itself was too large to install on my laptop.\u003c/p\u003e\n\u003ch2\u003eThe work\u003c/h2\u003e\n\u003cp\u003eAfter hacking the VoxLords multiplayer fork. I started by exploring multiple tech stacks concurrently and building a prototype in each of them. The stacks I looked at were Babylon.js, three.js, \u0026#38; Stackgl.\u003c/p\u003e\n\u003ch3\u003eTech stack requirements\u003c/h3\u003e\n\u003cp\u003eThe first requirement was support for the 3d asset pipeline. I had been working with voxel models in \u003ca href=\"https://ephtracy.github.io/\"\u003eMagicaVoxel .vox\u003c/a\u003e format. This was great for static entities. There\u0026#39;s primarily 2 ways to animate a voxel model. You can create frame based animation, in which you each frame of the animation is a separate voxel animation and then you morph or swap them out on at runtime. Or you can apply skeletal transformation data to voxel meshes. If you decide on the skeletal route you need to break the voxel mesh up into smaller mesh\u0026#39;s that correspond to the skeleton bones.\u003c/p\u003e\n\u003cp\u003eI had a character mesh that I wanted to use in .vox format but at the time MagicaVoxel did not support multiple meshes. I converted the .vox file to \u003ca href=\"https://www.getqubicle.com/\"\u003equiblce .qb\u003c/a\u003e file and broke the character up into separate meshes.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/qubicle.png'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/qubicle.png'\n       alt=\"Qubicle UI breaking a mesh up\"\n       title=\"Using Qubicle to break up a mesh for skeletal animation\"/\u003e\n\u003c/a\u003e\u003cp\u003eThe segmented qubicle mesh was then imported into Blender and animations were built in blender.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/blender.gif'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/blender.gif'\n       alt=\"Blender skeletal walking animation\"\n       title=\"voxel model animated in blender with skeletal animation\"/\u003e\n\u003c/a\u003e\u003cp\u003eThe animation data and voxel meshes data was combined at runtime in the engine.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://twitter.com/kevzettler/status/1002235365246222336?s=20\"\u003ehttps://twitter.com/kevzettler/status/1002235365246222336?s=20\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003eTech stack evaluation\u003c/h3\u003e\n\u003cul\u003e\u003cli\u003e\u003ca href=\"https://threejs.org/\"\u003ethree.js\u003c/a\u003e\u003cp\u003eVoxLords was built in Three.js so I looked at it first. The Three.js - Blender pipeline was broken and could not get skeletal animation imports working. A colleague of mine who was working on a Three.js project captured some of the \u003ca href=\"https://gist.github.com/AndrewRayCode/746be166c3008a03167206aec4a46531\"\u003e three.js blender exporter issues\u003c/a\u003e at the time. This was a deal breaker for me.\u003c/p\u003e\n\u003cp\u003eFurthermore, Three.js did not have a good headless server side offering. Three.js uses custom math libraries that were not easily extract-able from the rendering code. This meant multiplayer support would take a lot of extra duplicate work, re-implementing the game logic on the server. Three.js has advanced significantly since then, I don\u0026#39;t think these are issues anymore.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.babylonjs.com/\"\u003ebabylon.js\u003c/a\u003e\u003cp\u003eI made some immediate promising progress in Babylon.js. The asset pipeline was robust and supported skeletal animation data. Babylon has camera and physics out of the box. The Babylon team and  community was super responsive and supportive. I hit a wall with Babylon.js when trying to build out the multiplayer server. Like Three.js, Babylon.js had no headless mode. Again, this meant that building multiplayer would require duplicate work reproducing all the simulation logic and physics in the server side codebase. Recent versions of Babylon have a robust headless mode and have decoupled the framework into smaller libraries. These days Three.js is king of the normie browser 3d mind share lexicon but I still find Babylon.js a much better offering.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://stack.gl/\"\u003estackgl\u003c/a\u003e\u003cp\u003eStackgl is the dark-horse of this list. Stackgl is not trying to be a complete 3D engine like Three.js and Babylon.js. Stackgl is an ecosystem of small functional tools that can be composed to create 3d browser experiences. Stackgl follows the unix philosophy of \u0026#34;small sharp tools\u0026#34;. Stackgl has some main pillars: Rendering, Math, and Data. Stackgl handles rendering by focusing on direct shader code. Babylon.js and Three.js try to heavily abstract shaders away. Stackgl\u0026#39;s primary rendering module is \u003ca href=\"http://regl.party/\"\u003eRegl\u003c/a\u003e which provides a completely novel stateless rendering pattern. Stackgl then provides many small functional math modules for dealing with vertex and geometry data. I was quickly more productive in Stackgl than the previous two stacks.\u003c/p\u003e\n\u003cp\u003eThe modular nature made it very easy to share code between the client and server, easy to optimize performance and rendering, and easy to add custom functionality. For example Babylon.js and Three.js have their own vector math implementation libraries. Then if you use a physics engine with the physics engines have their own intern vector math libraries. furthermore if you use a multiplayer server you will need a vector math library there as well.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nIn Babylon and Three it becomes a lot of fake work converting and serializing between different vector implementations. In Stackgl you can easily use the same \u003ca href=\"https://glmatrix.net/\"\u003egl-matrix vector math library\u003c/a\u003e across a project which is a huge productivity gain.\u003ca href='/img/multiplayer-engine-post/engines.png'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/engines.png'\n       alt=\"Screenshotf of github showing multiple game engines\"\n       title=\"Which 3d browser engine is best?\" /\u003e\n\u003c/a\u003e\u003cp\u003e\u003cb\u003eWhen I started making progress with Stackgl I took a year off and worked on it full time throughout 2017.\u003c/b\u003e\u003c/p\u003e\n\u003ch2\u003eWhat went wrong\u003c/h2\u003e\n\u003cp\u003eUnfortunately, I consider this project unfinished. I did not ship a complete game experience and there are some issues with the engine that would be risky for production deployment. I\u0026#39;m writing this post to put closure on the project before moving on to new work and in the hopes that this experience may be useful to any others interested in this space.\u003c/p\u003e\n\u003ch4\u003eReact vs Vanilla Js\u003c/h4\u003e\n\u003cp\u003eMost my web development experience has been with the React framework and I thought it would be complementary to Regl and the stack.gl ecosystem\u0026#39;s functional paradigm. I created a \u003ca href=\"https://github.com/kevzettler/react-regl\"\u003ereact reconciler to bridge react and regl\u003c/a\u003e. I started using a React stack with Redux to manage all the game state and state transitions. This React+Redux combo turned out to be a huge boon when writing UI. Game developers in traditional engines constantly complain about UI being their least favorite task. This is because game engines use traditional 2-way mutable state management UI code that is error prone and brittle. Web developers have solved these UI complaints and built tools like React that make building UI\u0026#39;s easy.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/react.gif'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/react.gif'\n       alt=\"animated gif of a React 3d browser UI\"\n       title=\"React 3d player avatar creation system\" width=\"400\" /\u003e\n\u003c/a\u003e\u003cp\u003eReact+Redux setup was too much performance overhead for the real time game play section. The state updates through the Redux action reducer pipeline, combined with the minimal React render updates was enough to cause noticeable hiccups in the game play frame rate. Performance in the browser environment is very sensitive to garbage collector management. In order to minimize garbage collector hits you need to use object pooling. Object pooling is a mutable state management pattern in which you pre-allocate a pool of objects that will be mutated during the life of the program to minimize runtime memory allocations. This object pooling pattern conflicts with the immutable update patterns React and Redux are built upon. Hitting these performance issues was a big roadblock and essentially became a \u0026#39;rewrite\u0026#39; in which had to rewrite the game state management to be performance optimized. This was costly and took a lot of time.\u003c/p\u003e\n\u003ch4\u003eHobby time\u003c/h4\u003e\n\u003cp\u003eWhen I started making progress with Stackgl I took a year off and worked on it full time throughout 2017. I lived off some savings and unemployment checks until late 2018 I got back into corporate wage slavery from 2018-2020. A highlight during this time was I got invited to Animecon 2019 indie developer section to shill my game in the Indie game section.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/animecon.png'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/animecon.png'\n       alt=\"A photo of me at animecon 2019 \"\n       title=\"Playing a game with a 2B cosplayer at animecon 2019\" /\u003e\n\u003c/a\u003e\u003cp\u003eDuring this time I switched to hobby mode started putting less and less time into development I was maybe averaging 4 hours a week. I was distracted by day job work. This time shortage slowed development progress. Development picked up during 2020 Covid lockdowns unfortunately getting back into development after a hiatus presented some new challenges...\u003c/p\u003e\n\u003ch5\u003eSoftware entropy\u003c/h5\u003e\nThe JavaScript ecosystem is known for moving incredibly fast. When I got back into development I spent a lot of time fighting severe software entropy. Getting the project to build with latest dependency chains of Node+NPM+webpack etc took a lot of work. The animation pipeline using Landon had severe entropy. The Landon was a mix of Rust, JavaScript and Blender versions that were not strictly pinned. I had to do work to upgrade to the latest Blender export versions but then write backwards compatibility translation layers for the animation data. I upgraded my laptop to an M1 Mac. This triggered a roadblock on the project because the WebRTC module I was using would not compile on the new M1 apple silicon chip. This has since been resolved but was pretty much the show stopper.\u003ch2\u003eByproducts\u003c/h2\u003e\n\u003cp\u003eThe work put into this project spun-off some useful libraries that I have open sourced and put on github\u003c/p\u003e\n\u003cul\u003e\u003cli\u003e\u003ca href=\"https://github.com/kevzettler/react-regl\"\u003ereact-regl\u003c/a\u003e\u003cp\u003eA react reconciler to bridge react and regl\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/kevzettler/parse-magica-voxel\"\u003eparse-magica-voxel\u003c/a\u003e\u003cp\u003eA JavaScript parser for the magicavoxel .vox binary file format\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/kevzettler/parse-qubicle\"\u003eparse-quibicle\u003c/a\u003e\u003cp\u003eA JavaScript parser for the .qb binary file format.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/kevzettler/gl-swept-sphere-triangle\"\u003egl-swept-sphere-triangle\u003c/a\u003e\u003cp\u003eA swept sphere to polygon collision detection algorithm\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eShout outs\u003c/h2\u003e\n\u003cp\u003eThis project was built on the work and research of other highly skilled software engineers. Without their help\u003c/p\u003e\n\u003cul\u003e\u003cli\u003e\u003ca href=\"https://twitter.com/MikolaLysenko\"\u003eMikola lysenko\u003c/a\u003e\u003cp\u003eMikola is a primary driver of the stack.gl ecosystem and certified 10x genius developer. His blog \u003ca href=\"https://0fps.net\"\u003e0fps.net\u003c/a\u003e has some mind melting content on high performance computer science, and geometry. Mikola assembled a team and basically built a Roblox clone for China in the browser. The team got together for a podcast to discuss their \u003ca href=\"https://www.youtube.com/watch?v=Z_--8z549D4\"\u003eReflections on building web-based voxel MMO in China (Mikola Lysenko, et al) - YouTube\u003c/a\u003e  It is a highly insighful talk, highly recommend if you found this post interesting.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://chinedufn.com/\"\u003eChinedu Francis Nwafili\u003c/a\u003e\u003cp\u003eChinedu did amazing work by building the \u003ca href=\"https://github.com/chinedufn/skeletal-animation-system\"\u003estackgl skeletal animation system\u003c/a\u003e which is a key piece of the stack.gl ecosystem and this project was highly dependent on and probably couldn\u0026#39;t have come together without. While I was building out this project Chinedu was also building out his own game and engine we kept in correspondence while building and sharing ideas. Chinedu also built out a very cool suite of tools for Blender called \u003ca href=\"https://github.com/chinedufn/landon\"\u003elandon\u003c/a\u003e. Making Blender a source of truth for game engine data. Chinedu\u0026#39;s blog at \u003ca href=\"https://chinedufn.com/\"\u003ehttps://chinedufn.com/\u003c/a\u003e has in-depth development journal posts on his game engine development.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.jameswarlloyd.com/\"\u003eJames Warlloyd\u003c/a\u003e\u003cp\u003eJames created the \u003ca href=\"https://opengameart.org/content/voxel-mech-sniper\"\u003eoriginal mech model\u003c/a\u003e that I used as the bases for the character art in this engine.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eThe state of the art\u003c/h2\u003e\n\u003cp\u003eOverall this project was a big educational return on investment for me. I learned about hardcore browser optimization and many other data processing techniques. I have continued to do game ( and engine ) development as a hobby and have already looked into some other emerging technologies. My focus is still on browser multiplayer experiences. I haven\u0026#39;t found the big engines: Unreal, Unity, Godot have the best models for multiplayer. I have previously written about \u003ca href=\"https://radcade.com/how-to-add-network-multiplayer-to-your-indie-game/\"\u003emultilpayer game engine design for indies\u003c/a\u003e. The big engines have models that couple game simulation logic code to rendering code. This makes it challenging to build a server as you have to decouple the simulation and run it headless.\u003c/p\u003e\n\u003cul\u003e\u003cli\u003e\u003ca href=\"https://dotbigbang.com/\"\u003eDotBigBang\u003c/a\u003e\u003cp\u003eDotBigBang is everything this project attempted to be and more. It is multiplayer voxel 3d engine all fully in the browser. DotBigBang is focused on user generated content and is essentially a multiplayer game engine. You can get a group of people together and bring your avatars into a 3D scene and then collaboratively edit and program that scene. Like a multiplayer Unity editor experience. I had the fortune to hang with the founder of DotBigBang at GDC 2023 and hear about some of the impressive browser performance optimization they were doing. He told me about forking Chromium to have better performance debugging visibility into how the JIT compilation and memory usage of the browser was working.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/matrix-org/thirdroom#manifold-engine\"\u003eManifold engine\u003c/a\u003e\u003cp\u003eThe Manifold engine is a stealthy engine being developed by the \u003ca href=\"https://matrix.org/\"\u003ematrix.org\u003c/a\u003e team. Its currently embedded in a repository for another project with a disclaimer they might release it in the future. The host project is called \u0026#39;thirdroom\u0026#39; and is a multilpayer VR metaverse platform.\u003c/p\u003e\n\u003cp\u003eWhen I learned about Manifold I was very excited because it has the same design philosophy and high performance computation architecture that I had been building towards. It uses Web Workers to create multiple threads to separately process rendering, physics, and networking. All the threads share memory over a \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"\u003eSharedArrayBuffer\u003c/a\u003e and they use object pooling to reduce garbage collection. Manifold also has WebRTC Data channels for networking. I was able to build a promising prototype in Manifold unfortunately Manifold is tightly coupled to a matrix.org backend. The matrix backend has a clunky API to use which would make custom server side optimization challenging. If the matrix.org team ever decouples and delivers Manifold it would be very compelling option.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/AmbientRun/Ambient\"\u003eAmbient engine\u003c/a\u003e\u003cp\u003eAmbient is a promising new Rust lang engine. It is a default multiplayer engine. It shares code between client and server. It compiles game code to WASM and then acts as a cross platform binary runtime to execute that WASM. I have built a promising prototype in Ambient but unfortunately Ambient does not currently build for browser environments. The Ambient team is actively working to target browsers and are aiming for an upcoming release.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","excerpt":"Intro \u0026 TLDR;\nThis post is a retrospective on a multiplayer voxel browser game engine I built. This post will cover the squishy storytelling side of the project and the accompanying code repository has all of the hard technical details. This is essentially a 2 part post. Read this and read the repo README.\n\n  \nDisclaimer\nThis project is a bit old and stale at the time of this post. Some of the...","slug":"2023/04/25/multiplayer-voxel-game-engine","meta":{"keywords":"gamedev, javascript, react","image":"img/multilpayer-engine-post/meta.png","description":"Intro \u0026#38; TLDR;\nThis post is a retrospective on a multiplayer voxel browser game engine I built. This post will cover the squishy storytelling side of the project and the accompanying code repository has all of the hard technical details. This is essentially a 2 part post. Read this and read the r"}}},"__N_SSG":true},"page":"/[year]/[month]/[day]/[slug]","query":{"year":"2023","month":"04","day":"25","slug":"multiplayer-voxel-game-engine"},"buildId":"ouxHwMCqjJSaphqO_humA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>