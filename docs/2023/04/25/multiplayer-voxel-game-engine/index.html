<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>I built a multiplayer voxel browser game engine.<!-- --> - Kev Zettler</title><meta property="og:title" content="I built a multiplayer voxel browser game engine. - Kev Zettler"/><meta property="og:image" content="https://kevzettler.com/img/multiplayer-engine-post/meta.png"/><meta name="description" content="I open sourced my HTML5 multiplayer 3D voxel browser game engine."/><meta property="og:description" content="I open sourced my HTML5 multiplayer 3D voxel browser game engine."/><meta name="keywords" content="game dev, javascript, react"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@kevzettler"/><meta name="twitter:creator" content="@kevzettler"/><meta name="twitter:title" content="I built a multiplayer voxel browser game engine. - Kev Zettler"/><meta name="twitter:description" content="I open sourced my HTML5 multiplayer 3D voxel browser game engine."/><meta name="twitter:image" content="https://kevzettler.com/img/multiplayer-engine-post/meta.png"/><meta name="twitter:image:width" content="4096"/><meta name="twitter:image:height" content="2701"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/616df6187075e4dc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/616df6187075e4dc.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/js/jquery-3.6.4.min.js" defer="" data-nscript="beforeInteractive"></script><script src="/js/vendor/highlight/highlight.min.js" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-3479d0a64c7ffb47.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08ad0149ddcbdd04.js" defer=""></script><script src="/_next/static/chunks/189-925753359219706e.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-e0449cfeaee8cb7c.js" defer=""></script><script src="/_next/static/vUyWxDfyKr2O4J8LUYO2n/_buildManifest.js" defer=""></script><script src="/_next/static/vUyWxDfyKr2O4J8LUYO2n/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><div class="container"><button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="brand" href="/">Kev Zettler</a><div class="nav-collapse collapse"><ul class="nav"><li class=""><a href="/">Blog</a></li><li class=""><a href="/about">About</a></li></ul></div></div></div></div><div class="container" id="body-content"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="post cell"><h1>I built a multiplayer voxel browser game engine.</h1><h4 class="large-bottom">Posted on <!-- -->2023-04-25</h4><div class="content"><h2>Intro &amp; TLDR;</h2>
<p>This post is a retrospective on a <a href="https://github.com/kevzettler/multiplayer-voxel-browser-game-engine">multiplayer voxel browser game engine</a> I built. This post will cover the squishy storytelling side of the project, and the <a href="https://github.com/kevzettler/multiplayer-voxel-browser-game-engine">accompanying code repository</a> has all of the intricate technical details. This post is essentially a 2 part post. Read this and read the repo README.</p>
<a href="/img/multiplayer-engine-post/play.gif">
  <img src="/img/multiplayer-engine-post/play.gif" alt="Animated give of a 3d multiplayer browser engine" title="Demonstration of multiplayer game engine multiple players"/>
</a><h3>Disclaimer</h3>
<p>This project is a bit old and stale at the time of this post. Some of the tech decisions made sense during development but are questionable today. I will try to address that in this post. I started this project with very minimal game development experience. I had no idea how many things worked, shaders, 3d asset files, raw binary buffer manipulation, scene graphs, and physics engines. I learned all these skills and more during this project. This experience also helped me later land some major corporate jobs. This project was primarily active from 2017-2019; however, exploration for the project goes back to late 2016.</p>
<a href="/img/multiplayer-engine-post/disclaimer.png">
  <img src="/img/multiplayer-engine-post/disclaimer.png" alt="Should you build a custom engine? Yes." title="Should you build a custom engine? Yes" width="400"/>
</a><h2>Inspiration &amp; motivation</h2>
<p>I wanted to build a multiplayer browser game. I was very inspired by <code>.io</code> games and sites like <a href="https://iogames.space/">iogames.space</a>. I love the <code>.io</code> gaming experience of copy-pasting a URL around and getting in a game with your friends. Furthermore, I wanted to recreate a canceled MMO called <a href="https://en.wikipedia.org/wiki/Exteel">Exteel</a>. My background was in web development and design. I stuck with the tools and environment I was most familiar with.</p>
<h3>Target features</h3>
<ul><li>network multiplayer</li>
<li>playable cross-platform in the browser</li>
<li>Player avatar customization</li>
<li>lazy loading assets</li>
<li>shared client &amp; server game code</li>
<li>third person camera</li>
<li>platforming physics</li>
<li>destructible environments</li>
</ul>
<p>I completed most of these features except for destructible environments. Destructible environments were a big driver for the voxel asset pipeline, assuming voxels would enable the destructibility. Another browser game <a href="https://github.com/Lallassu/VoxLords">VoxLords</a> inspired the goal of destructible environments. VoxLords had good environmental destruction and captured my imagination. I started this out by forking and modifying VoxLords to be multiplayer.</p>
<p><a href="https://twitter.com/lallassu/status/725401257377169409?s=20">https://twitter.com/lallassu/status/725401257377169409?s=20</a></p>
<p>After hacking on VoxLords, it was clear that making a captivating 3D multiplayer browser experience was possible. Unfortunately, Lallassu was correct, and there were some major performance issues in the VoxLords engine that would require extensive refactoring. I decided to start a new project.</p>
<h4>Why I didn&#x27;t use one of the megacorp engines</h4>
<p>I was not happy with Unity and Unreal&#x27;s HTML5 browser experience. Unity&#x27;s HTML5 export creates a giant asset bundle where users must sit and watch a loading bar before playing. This loading bar experience was against my goals of lazy loading assets on demand. Additionally, Unity&#x27;s multiplayer server-side support was sketchy and <a href="https://radcade.com/unity-multiplayer-netcode-for-gameobjects/">still is</a>. Unreal had much stronger multiplayer support but similar issues with browser builds, and in addition, Unreal itself was too large to install on my laptop.</p>
<h2>The work</h2>
<p>After hacking the VoxLords multiplayer fork, I started by exploring multiple tech stacks concurrently and building a prototype in each. The stacks I looked at were Babylon.js, Three.js, &amp; Stackgl.</p>
<h3>Tech stack requirements</h3>
<p>The first requirement was support for the 3d asset pipeline. I had been working with voxel models in <a href="https://ephtracy.github.io/">MagicaVoxel .vox</a> format. The .vox format was great for static entities. There are primarily two ways to animate a voxel model. You can create frame-based animation, in which each frame is a separate voxel animation, and then you morph or swap them out at runtime. Or you can apply skeletal transformation data to voxel meshes. If you decide on the skeletal route, you must break the voxel mesh into smaller meshes corresponding to the skeleton bones.</p>
<p>I had a character mesh that I wanted to use in .vox format, but at the time MagicaVoxel did not support multiple meshes. I converted the .vox file to <a href="https://www.getqubicle.com/">quiblce .qb</a> file and broke the character up into separate meshes.</p>
<a href="/img/multiplayer-engine-post/qubicle.png">
  <img src="/img/multiplayer-engine-post/qubicle.png" alt="Qubicle UI breaking a mesh up." title="Using Qubicle to break up a mesh for skeletal animation"/>
</a><p>I then imported the segmented Qubicle mesh into Blender and built the skeletal animations in Blender.</p>
<a href="/img/multiplayer-engine-post/blender.gif">
  <img src="/img/multiplayer-engine-post/blender.gif" alt="Blender skeletal walking animation." title="Voxel model animated in Blender with skeletal animation"/>
</a><p>The engine then combines the animation data and voxel mesh data at runtime.</p>
<h3>Tech stack evaluation</h3>
<ul><li><a href="https://threejs.org/">three.js</a><p>I looked at Three.js first because VoxLords was built with it. The Three.js - Blender pipeline had issues, and we could not utilize skeletal animation imports. A colleague of mine who was working on a Three.js project captured some of the <a href="https://gist.github.com/AndrewRayCode/746be166c3008a03167206aec4a46531"> three.js blender exporter issues</a> at the time. The Three.js - Blender compatibility issues were a deal breaker for me.</p>
<p>Furthermore, Three.js did not have a viable headless server-side offering. Three.js uses custom math libraries that were not easily extractable from the rendering code. This tight coupling of math primitives and client render code meant multiplayer support would take a lot of extra duplicate work, re-implementing the game logic on the server. Three.js has advanced significantly since then, and I don&#x27;t think these are issues anymore.</p>
</li>
<li><a href="https://www.babylonjs.com/">babylon.js</a><p>I made some immediate promising progress in Babylon.js. The asset pipeline was robust and supported skeletal animation data. Babylon has a camera and physics out of the box. The Babylon team and community were super responsive and supportive. I hit a wall with Babylon.js when building the multiplayer server. Like Three.js, Babylon.js had no headless mode. Again, building multiplayer would require duplicate work reproducing all the simulation logic and physics in the server-side codebase. Recent versions of Babylon have a robust headless mode and have decoupled the framework into smaller libraries. These days Three.js is the king of the normie mindshare lexicon, but I still find Babylon.js a much better offering.</p>
</li>
<li><a href="http://stack.gl/">stackgl</a><p>Stackgl is the dark horse of this list. Stackgl is not trying to be a complete 3D engine like Three.js and Babylon.js. Stackgl is an ecosystem of small functional tools that can be composed to create 3d browser experiences. Stackgl follows the Unix philosophy of &quot;small sharp tools.&quot; Stackgl has some main pillars: Rendering, Math, and Data. Stackgl handles rendering by focusing on direct shader code. Babylon.js and Three.js try to abstract shaders heavily away. Stackgl&#x27;s primary rendering module is <a href="http://regl.party/">Regl</a>, which provides an entirely novel stateless rendering pattern. Stackgl then provides many small functional math modules for vertex and geometry data. I was quickly more productive in Stackgl than in the previous two stacks.</p>
<p>The modular nature made it very easy to share code between the client and server, easy to optimize performance and rendering, and easy to add custom functionality. For example, Babylon.js and Three.js have their own vector math implementation libraries. Then if you use a physics engine, the physics engines have their internal vector math libraries. Furthermore, if you use a multiplayer server, you will also need a vector math library there.</p>
</li>
</ul>
In Babylon and Three, it becomes a lot of fake work converting and serializing between different vector implementations. In Stackgl, you can easily use the same <a href="https://glmatrix.net/">gl-matrix vector math library</a> across a project which is a huge productivity gain.<a href="/img/multiplayer-engine-post/engines.png">
  <img src="/img/multiplayer-engine-post/engines.png" alt="Screenshot of GitHub showing multiple game engines." title="Which 3d browser engine is best?"/>
</a><p><b>When I started progressing with Stackgl, I took a year off and worked on it full-time throughout 2017.</b></p>
<h2>What went wrong</h2>
<p>Unfortunately, I consider this project unfinished. I did not ship a complete game experience, and there are some issues with the engine that would be risky for production deployment. I&#x27;m writing this post to put closure on the project before moving on to new work and in the hopes that this experience may be helpful to any others interested in this space.</p>
<h4>React vs. Vanilla Js</h4>
<p>Most of my web development experience has been with the React framework, and I thought it would complement Regl and the Stackgl ecosystem&#x27;s functional paradigm. I created a <a href="https://github.com/kevzettler/react-regl">react reconciler to bridge React and Regl</a>. I started using a React stack with Redux to manage all the game state and state transitions. This React+Redux combo turned out to be a huge boon when writing UI. Game developers in traditional engines constantly complain about UI being their least favorite task. The game dev UI complaint is because game engines use geriatric 2-way mutable state management UI code that is error-prone and brittle. Web developers have solved these UI complaints and built tools like React that make creating UIs easy.</p>
<a href="/img/multiplayer-engine-post/react.gif">
  <img src="/img/multiplayer-engine-post/react.gif" alt="animated gif of a React 3d browser UI." title="React 3d player avatar creation system" width="400"/>
</a><p>React+Redux setup was too much performance overhead for the real-time gameplay section. The state updates through the Redux action reducer pipeline, and the minimal React render updates were enough to cause noticeable hiccups in the gameplay frame rate. Performance in the browser environment is susceptible to garbage collector management. To minimize garbage collector hits, you need to use object pooling. Object pooling is a mutable state management pattern in which you pre-allocate a pool of objects. The collection of allocated objects gets mutated and reused during the program&#x27;s life to minimize runtime memory allocations. This object pooling pattern conflicts with the immutable update patterns of React and Redux. Hitting these performance issues was a significant roadblock and essentially became a &#x27;rewrite&#x27; in which I had to rewrite the game state management to be performance optimized. This rewrite was costly and took a lot of time.</p>
<h4>Hobby time</h4>
<p>When I started progressing with Stackgl, I took a year off and worked on it full-time throughout 2017. I lived off some savings and unemployment checks until late 2018. I got back into corporate wage slavery from 2018-2020. During this time, I was invited to Animecon 2019 indie developer section to shill my game in the Indie game section.</p>
<a href="/img/multiplayer-engine-post/animecon.png">
  <img src="/img/multiplayer-engine-post/animecon.png" alt="A photo of me at Animecon 2019." title="Playing a game with a 2B cosplayer at Animecon 2019"/>
</a><p>During this time, I switched to hobby mode and started putting less and less time into development. I was maybe averaging 4 hours a week. I was distracted by day job work. This time shortage slowed development progress. Development picked up during the 2020 Covid lockdowns. Unfortunately, returning to development after a hiatus presented some new challenges.</p>
<h5>Software entropy</h5>
The JavaScript ecosystem is known for moving incredibly fast. I spent much time-fighting severe software entropy when I returned to development. Getting the project to build with the latest dependency chains of Node+NPM+webpack etc., took a lot of work. The animation pipeline using Landon had severe entropy. Landon is a mix of Rust, JavaScript, and Blender versions that are not strictly pinned. The Landon developer was changing the data output format and abandoned the skeletal animation system I used. I had to do work to upgrade to the latest Blender export versions but then write backward compatibility translation layers for the animation data. I upgraded my laptop to an M1 Mac. The M1 transition triggered a roadblock on the project because the WebRTC module I used would not compile on the new M1 Apple silicon chip. The WebRTC module now supports M1 architectures but was pretty much the show-stopper.<h2>Byproducts</h2>
<p>The work put into this project spun off some valuable libraries I have open-sourced and put on GitHub.</p>
<ul><li><a href="https://github.com/kevzettler/react-regl">react-regl</a><p>A react reconciler to bridge React and Regl</p>
</li>
<li><a href="https://github.com/kevzettler/parse-magica-voxel">parse-magica-voxel</a><p>A JavaScript parser for the Magicavoxel .vox binary file format</p>
</li>
<li><a href="https://github.com/kevzettler/parse-qubicle">parse-quibicle</a><p>A JavaScript parser for the .qb binary file format.</p>
</li>
<li><a href="https://github.com/kevzettler/gl-swept-sphere-triangle">gl-swept-sphere-triangle</a><p>A swept sphere to polygon collision detection algorithm</p>
</li>
</ul>
<h2>Shout outs</h2>
<p>I built this project with the help and research of other highly skilled software engineers. Their contributions were critical to the development of this project.</p>
<ul><li><a href="https://twitter.com/MikolaLysenko">Mikola lysenko</a><p>Mikola is a primary driver of the Stackgl ecosystem and a certified 10x genius developer. His blog <a href="https://0fps.net">0fps.net</a> has some mind-melting content on high-performance computer science and geometry. Mikola assembled a team and built a Roblox clone for China in the browser. The team got together for a podcast to discuss their <a href="https://www.youtube.com/watch?v=Z_--8z549D4">Reflections on building web-based voxel MMO in China (Mikola Lysenko, et al) - YouTube</a>  It is a highly insightful talk, highly recommend if you found this post interesting.</p>
</li>
<li><a href="https://chinedufn.com/">Chinedu Francis Nwafili</a><p>Chinedu did terrific work by building the <a href="https://github.com/chinedufn/skeletal-animation-system">stackgl skeletal animation system</a>, which is a vital piece of the Stackgl ecosystem, and this project was highly dependent on and probably couldn&#x27;t have come together without. While I was building this project, Chinedu also created his own game and engine. We kept in correspondence while making and sharing ideas. Chinedu also built out a very cool suite of tools for Blender called <a href="https://github.com/chinedufn/landon">landon</a>. Landon makes Blender a source of truth for game engine data. Chinedu&#x27;s blog at <a href="https://chinedufn.com/">https://chinedufn.com/</a> has in-depth development journal posts on his game engine development.</p>
</li>
<li><a href="http://www.jameswarlloyd.com/">James Warlloyd</a><p>James created the <a href="https://opengameart.org/content/voxel-mech-sniper">original mech model</a> that I used as the bases for the character art in this engine.</p>
</li>
</ul>
<h2>The state of the art</h2>
<p>Overall this project was a significant educational return on investment for me. I learned about hardcore browser optimization and many other data-processing techniques. I have continued to do game ( and engine ) development as a hobby and have already looked into some other emerging technologies. My focus is still on browser multiplayer experiences. I haven&#x27;t found the big engines: Unreal, Unity, and Godot have the best models for multiplayer. I have previously written about <a href="https://radcade.com/how-to-add-network-multiplayer-to-your-indie-game/">multiplayer game engine design for indies</a>. The big engines use coding patterns that couple game simulation code to rendering code. This coupling makes it challenging to build a server as you have to decouple the simulation and run it headless.</p>
<ul><li><a href="https://dotbigbang.com/">DotBigBang</a><p>DotBigBang is everything this project attempted to be and more. It is a multiplayer voxel 3d engine, all fully in the browser. DotBigBang is focused on user-generated content and is essentially a multiplayer game engine. You can get a group of people together, bring your avatars into a 3D scene, and then collaboratively edit and program that scene like a multiplayer Unity editor experience. I had the fortune to hang with the founder of DotBigBang at GDC 2023 and hear about some impressive browser performance optimization they were doing. He told me about forking Chromium to have better performance debugging visibility into how the JIT compilation and memory usage of the browser was working.</p>
</li>
<li><a href="https://github.com/matrix-org/thirdroom#manifold-engine">Manifold engine</a><p>The Manifold engine is a stealthy engine currently in development by the <a href="https://matrix.org/">matrix.org</a> team. Manifold is embedded in a repository for another project with a disclaimer they might release in the future. The host project is &#x27;Thirdroom,&#x27; a multiplayer VR metaverse platform.</p>
<p>When I learned about Manifold I was very excited because it has the same design philosophy and high-performance computation architecture that I had been building towards. It uses Web Workers to create multiple threads to process rendering, physics, and networking separately. All the threads share memory over a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffer</a>, and they use object pooling to reduce garbage collection. Manifold also has WebRTC Data channels for networking. I built a promising prototype in Manifold; unfortunately, Manifold is tightly coupled to a matrix.org backend. The matrix backend has a clunky API to use, which would make custom server-side optimization challenging. If the matrix.org team ever decouples and delivers Manifold, it would be a very compelling option.</p>
</li>
<li><a href="https://github.com/AmbientRun/Ambient">Ambient engine</a><p>Ambient is a promising new Rust lang engine. It is a default multiplayer engine. It shares code between the client and server. It compiles game code to WASM and then acts as a cross-platform binary runtime to execute that WASM. I have built a promising prototype in Ambient but unfortunately Ambient does not currently make for browser environments. The Ambient team is actively working to target browsers and is aiming for an upcoming release.</p>
</li>
</ul>
</div><div><hr/><div style="overflow:hidden"><p style="float:left">If you enjoyed this article, consider following me <a href="https://www.twitter.com/kevzettler">on Twitter</a></p></div><hr/><div><h2>Comments:</h2><div id="disqus_thread"></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"I built a multiplayer voxel browser game engine.","date":"2023-04-25","contentHTML":"\u003ch2\u003eIntro \u0026#38; TLDR;\u003c/h2\u003e\n\u003cp\u003eThis post is a retrospective on a \u003ca href=\"https://github.com/kevzettler/multiplayer-voxel-browser-game-engine\"\u003emultiplayer voxel browser game engine\u003c/a\u003e I built. This post will cover the squishy storytelling side of the project, and the \u003ca href=\"https://github.com/kevzettler/multiplayer-voxel-browser-game-engine\"\u003eaccompanying code repository\u003c/a\u003e has all of the intricate technical details. This post is essentially a 2 part post. Read this and read the repo README.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/play.gif'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/play.gif'\n       alt=\"Animated give of a 3d multiplayer browser engine\"\n       title=\"Demonstration of multiplayer game engine multiple players\" /\u003e\n\u003c/a\u003e\u003ch3\u003eDisclaimer\u003c/h3\u003e\n\u003cp\u003eThis project is a bit old and stale at the time of this post. Some of the tech decisions made sense during development but are questionable today. I will try to address that in this post. I started this project with very minimal game development experience. I had no idea how many things worked, shaders, 3d asset files, raw binary buffer manipulation, scene graphs, and physics engines. I learned all these skills and more during this project. This experience also helped me later land some major corporate jobs. This project was primarily active from 2017-2019; however, exploration for the project goes back to late 2016.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/disclaimer.png'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/disclaimer.png'\n       alt=\"Should you build a custom engine? Yes.\"\n       title=\"Should you build a custom engine? Yes\" width=\"400\" /\u003e\n\u003c/a\u003e\u003ch2\u003eInspiration \u0026#38; motivation\u003c/h2\u003e\n\u003cp\u003eI wanted to build a multiplayer browser game. I was very inspired by \u003ccode\u003e.io\u003c/code\u003e games and sites like \u003ca href=\"https://iogames.space/\"\u003eiogames.space\u003c/a\u003e. I love the \u003ccode\u003e.io\u003c/code\u003e gaming experience of copy-pasting a URL around and getting in a game with your friends. Furthermore, I wanted to recreate a canceled MMO called \u003ca href=\"https://en.wikipedia.org/wiki/Exteel\"\u003eExteel\u003c/a\u003e. My background was in web development and design. I stuck with the tools and environment I was most familiar with.\u003c/p\u003e\n\u003ch3\u003eTarget features\u003c/h3\u003e\n\u003cul\u003e\u003cli\u003enetwork multiplayer\u003c/li\u003e\n\u003cli\u003eplayable cross-platform in the browser\u003c/li\u003e\n\u003cli\u003ePlayer avatar customization\u003c/li\u003e\n\u003cli\u003elazy loading assets\u003c/li\u003e\n\u003cli\u003eshared client \u0026#38; server game code\u003c/li\u003e\n\u003cli\u003ethird person camera\u003c/li\u003e\n\u003cli\u003eplatforming physics\u003c/li\u003e\n\u003cli\u003edestructible environments\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI completed most of these features except for destructible environments. Destructible environments were a big driver for the voxel asset pipeline, assuming voxels would enable the destructibility. Another browser game \u003ca href=\"https://github.com/Lallassu/VoxLords\"\u003eVoxLords\u003c/a\u003e inspired the goal of destructible environments. VoxLords had good environmental destruction and captured my imagination. I started this out by forking and modifying VoxLords to be multiplayer.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://twitter.com/lallassu/status/725401257377169409?s=20\"\u003ehttps://twitter.com/lallassu/status/725401257377169409?s=20\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAfter hacking on VoxLords, it was clear that making a captivating 3D multiplayer browser experience was possible. Unfortunately, Lallassu was correct, and there were some major performance issues in the VoxLords engine that would require extensive refactoring. I decided to start a new project.\u003c/p\u003e\n\u003ch4\u003eWhy I didn\u0026#39;t use one of the megacorp engines\u003c/h4\u003e\n\u003cp\u003eI was not happy with Unity and Unreal\u0026#39;s HTML5 browser experience. Unity\u0026#39;s HTML5 export creates a giant asset bundle where users must sit and watch a loading bar before playing. This loading bar experience was against my goals of lazy loading assets on demand. Additionally, Unity\u0026#39;s multiplayer server-side support was sketchy and \u003ca href=\"https://radcade.com/unity-multiplayer-netcode-for-gameobjects/\"\u003estill is\u003c/a\u003e. Unreal had much stronger multiplayer support but similar issues with browser builds, and in addition, Unreal itself was too large to install on my laptop.\u003c/p\u003e\n\u003ch2\u003eThe work\u003c/h2\u003e\n\u003cp\u003eAfter hacking the VoxLords multiplayer fork, I started by exploring multiple tech stacks concurrently and building a prototype in each. The stacks I looked at were Babylon.js, Three.js, \u0026#38; Stackgl.\u003c/p\u003e\n\u003ch3\u003eTech stack requirements\u003c/h3\u003e\n\u003cp\u003eThe first requirement was support for the 3d asset pipeline. I had been working with voxel models in \u003ca href=\"https://ephtracy.github.io/\"\u003eMagicaVoxel .vox\u003c/a\u003e format. The .vox format was great for static entities. There are primarily two ways to animate a voxel model. You can create frame-based animation, in which each frame is a separate voxel animation, and then you morph or swap them out at runtime. Or you can apply skeletal transformation data to voxel meshes. If you decide on the skeletal route, you must break the voxel mesh into smaller meshes corresponding to the skeleton bones.\u003c/p\u003e\n\u003cp\u003eI had a character mesh that I wanted to use in .vox format, but at the time MagicaVoxel did not support multiple meshes. I converted the .vox file to \u003ca href=\"https://www.getqubicle.com/\"\u003equiblce .qb\u003c/a\u003e file and broke the character up into separate meshes.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/qubicle.png'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/qubicle.png'\n       alt=\"Qubicle UI breaking a mesh up.\"\n       title=\"Using Qubicle to break up a mesh for skeletal animation\"/\u003e\n\u003c/a\u003e\u003cp\u003eI then imported the segmented Qubicle mesh into Blender and built the skeletal animations in Blender.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/blender.gif'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/blender.gif'\n       alt=\"Blender skeletal walking animation.\"\n       title=\"Voxel model animated in Blender with skeletal animation\"/\u003e\n\u003c/a\u003e\u003cp\u003eThe engine then combines the animation data and voxel mesh data at runtime.\u003c/p\u003e\n\u003ch3\u003eTech stack evaluation\u003c/h3\u003e\n\u003cul\u003e\u003cli\u003e\u003ca href=\"https://threejs.org/\"\u003ethree.js\u003c/a\u003e\u003cp\u003eI looked at Three.js first because VoxLords was built with it. The Three.js - Blender pipeline had issues, and we could not utilize skeletal animation imports. A colleague of mine who was working on a Three.js project captured some of the \u003ca href=\"https://gist.github.com/AndrewRayCode/746be166c3008a03167206aec4a46531\"\u003e three.js blender exporter issues\u003c/a\u003e at the time. The Three.js - Blender compatibility issues were a deal breaker for me.\u003c/p\u003e\n\u003cp\u003eFurthermore, Three.js did not have a viable headless server-side offering. Three.js uses custom math libraries that were not easily extractable from the rendering code. This tight coupling of math primitives and client render code meant multiplayer support would take a lot of extra duplicate work, re-implementing the game logic on the server. Three.js has advanced significantly since then, and I don\u0026#39;t think these are issues anymore.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.babylonjs.com/\"\u003ebabylon.js\u003c/a\u003e\u003cp\u003eI made some immediate promising progress in Babylon.js. The asset pipeline was robust and supported skeletal animation data. Babylon has a camera and physics out of the box. The Babylon team and community were super responsive and supportive. I hit a wall with Babylon.js when building the multiplayer server. Like Three.js, Babylon.js had no headless mode. Again, building multiplayer would require duplicate work reproducing all the simulation logic and physics in the server-side codebase. Recent versions of Babylon have a robust headless mode and have decoupled the framework into smaller libraries. These days Three.js is the king of the normie mindshare lexicon, but I still find Babylon.js a much better offering.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://stack.gl/\"\u003estackgl\u003c/a\u003e\u003cp\u003eStackgl is the dark horse of this list. Stackgl is not trying to be a complete 3D engine like Three.js and Babylon.js. Stackgl is an ecosystem of small functional tools that can be composed to create 3d browser experiences. Stackgl follows the Unix philosophy of \u0026#34;small sharp tools.\u0026#34; Stackgl has some main pillars: Rendering, Math, and Data. Stackgl handles rendering by focusing on direct shader code. Babylon.js and Three.js try to abstract shaders heavily away. Stackgl\u0026#39;s primary rendering module is \u003ca href=\"http://regl.party/\"\u003eRegl\u003c/a\u003e, which provides an entirely novel stateless rendering pattern. Stackgl then provides many small functional math modules for vertex and geometry data. I was quickly more productive in Stackgl than in the previous two stacks.\u003c/p\u003e\n\u003cp\u003eThe modular nature made it very easy to share code between the client and server, easy to optimize performance and rendering, and easy to add custom functionality. For example, Babylon.js and Three.js have their own vector math implementation libraries. Then if you use a physics engine, the physics engines have their internal vector math libraries. Furthermore, if you use a multiplayer server, you will also need a vector math library there.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nIn Babylon and Three, it becomes a lot of fake work converting and serializing between different vector implementations. In Stackgl, you can easily use the same \u003ca href=\"https://glmatrix.net/\"\u003egl-matrix vector math library\u003c/a\u003e across a project which is a huge productivity gain.\u003ca href='/img/multiplayer-engine-post/engines.png'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/engines.png'\n       alt=\"Screenshot of GitHub showing multiple game engines.\"\n       title=\"Which 3d browser engine is best?\" /\u003e\n\u003c/a\u003e\u003cp\u003e\u003cb\u003eWhen I started progressing with Stackgl, I took a year off and worked on it full-time throughout 2017.\u003c/b\u003e\u003c/p\u003e\n\u003ch2\u003eWhat went wrong\u003c/h2\u003e\n\u003cp\u003eUnfortunately, I consider this project unfinished. I did not ship a complete game experience, and there are some issues with the engine that would be risky for production deployment. I\u0026#39;m writing this post to put closure on the project before moving on to new work and in the hopes that this experience may be helpful to any others interested in this space.\u003c/p\u003e\n\u003ch4\u003eReact vs. Vanilla Js\u003c/h4\u003e\n\u003cp\u003eMost of my web development experience has been with the React framework, and I thought it would complement Regl and the Stackgl ecosystem\u0026#39;s functional paradigm. I created a \u003ca href=\"https://github.com/kevzettler/react-regl\"\u003ereact reconciler to bridge React and Regl\u003c/a\u003e. I started using a React stack with Redux to manage all the game state and state transitions. This React+Redux combo turned out to be a huge boon when writing UI. Game developers in traditional engines constantly complain about UI being their least favorite task. The game dev UI complaint is because game engines use geriatric 2-way mutable state management UI code that is error-prone and brittle. Web developers have solved these UI complaints and built tools like React that make creating UIs easy.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/react.gif'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/react.gif'\n       alt=\"animated gif of a React 3d browser UI.\"\n       title=\"React 3d player avatar creation system\" width=\"400\" /\u003e\n\u003c/a\u003e\u003cp\u003eReact+Redux setup was too much performance overhead for the real-time gameplay section. The state updates through the Redux action reducer pipeline, and the minimal React render updates were enough to cause noticeable hiccups in the gameplay frame rate. Performance in the browser environment is susceptible to garbage collector management. To minimize garbage collector hits, you need to use object pooling. Object pooling is a mutable state management pattern in which you pre-allocate a pool of objects. The collection of allocated objects gets mutated and reused during the program\u0026#39;s life to minimize runtime memory allocations. This object pooling pattern conflicts with the immutable update patterns of React and Redux. Hitting these performance issues was a significant roadblock and essentially became a \u0026#39;rewrite\u0026#39; in which I had to rewrite the game state management to be performance optimized. This rewrite was costly and took a lot of time.\u003c/p\u003e\n\u003ch4\u003eHobby time\u003c/h4\u003e\n\u003cp\u003eWhen I started progressing with Stackgl, I took a year off and worked on it full-time throughout 2017. I lived off some savings and unemployment checks until late 2018. I got back into corporate wage slavery from 2018-2020. During this time, I was invited to Animecon 2019 indie developer section to shill my game in the Indie game section.\u003c/p\u003e\n\u003ca href='/img/multiplayer-engine-post/animecon.png'\u003e\n  \u003cimg src='/img/multiplayer-engine-post/animecon.png'\n       alt=\"A photo of me at Animecon 2019.\"\n       title=\"Playing a game with a 2B cosplayer at Animecon 2019\" /\u003e\n\u003c/a\u003e\u003cp\u003eDuring this time, I switched to hobby mode and started putting less and less time into development. I was maybe averaging 4 hours a week. I was distracted by day job work. This time shortage slowed development progress. Development picked up during the 2020 Covid lockdowns. Unfortunately, returning to development after a hiatus presented some new challenges.\u003c/p\u003e\n\u003ch5\u003eSoftware entropy\u003c/h5\u003e\nThe JavaScript ecosystem is known for moving incredibly fast. I spent much time-fighting severe software entropy when I returned to development. Getting the project to build with the latest dependency chains of Node+NPM+webpack etc., took a lot of work. The animation pipeline using Landon had severe entropy. Landon is a mix of Rust, JavaScript, and Blender versions that are not strictly pinned. The Landon developer was changing the data output format and abandoned the skeletal animation system I used. I had to do work to upgrade to the latest Blender export versions but then write backward compatibility translation layers for the animation data. I upgraded my laptop to an M1 Mac. The M1 transition triggered a roadblock on the project because the WebRTC module I used would not compile on the new M1 Apple silicon chip. The WebRTC module now supports M1 architectures but was pretty much the show-stopper.\u003ch2\u003eByproducts\u003c/h2\u003e\n\u003cp\u003eThe work put into this project spun off some valuable libraries I have open-sourced and put on GitHub.\u003c/p\u003e\n\u003cul\u003e\u003cli\u003e\u003ca href=\"https://github.com/kevzettler/react-regl\"\u003ereact-regl\u003c/a\u003e\u003cp\u003eA react reconciler to bridge React and Regl\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/kevzettler/parse-magica-voxel\"\u003eparse-magica-voxel\u003c/a\u003e\u003cp\u003eA JavaScript parser for the Magicavoxel .vox binary file format\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/kevzettler/parse-qubicle\"\u003eparse-quibicle\u003c/a\u003e\u003cp\u003eA JavaScript parser for the .qb binary file format.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/kevzettler/gl-swept-sphere-triangle\"\u003egl-swept-sphere-triangle\u003c/a\u003e\u003cp\u003eA swept sphere to polygon collision detection algorithm\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eShout outs\u003c/h2\u003e\n\u003cp\u003eI built this project with the help and research of other highly skilled software engineers. Their contributions were critical to the development of this project.\u003c/p\u003e\n\u003cul\u003e\u003cli\u003e\u003ca href=\"https://twitter.com/MikolaLysenko\"\u003eMikola lysenko\u003c/a\u003e\u003cp\u003eMikola is a primary driver of the Stackgl ecosystem and a certified 10x genius developer. His blog \u003ca href=\"https://0fps.net\"\u003e0fps.net\u003c/a\u003e has some mind-melting content on high-performance computer science and geometry. Mikola assembled a team and built a Roblox clone for China in the browser. The team got together for a podcast to discuss their \u003ca href=\"https://www.youtube.com/watch?v=Z_--8z549D4\"\u003eReflections on building web-based voxel MMO in China (Mikola Lysenko, et al) - YouTube\u003c/a\u003e  It is a highly insightful talk, highly recommend if you found this post interesting.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://chinedufn.com/\"\u003eChinedu Francis Nwafili\u003c/a\u003e\u003cp\u003eChinedu did terrific work by building the \u003ca href=\"https://github.com/chinedufn/skeletal-animation-system\"\u003estackgl skeletal animation system\u003c/a\u003e, which is a vital piece of the Stackgl ecosystem, and this project was highly dependent on and probably couldn\u0026#39;t have come together without. While I was building this project, Chinedu also created his own game and engine. We kept in correspondence while making and sharing ideas. Chinedu also built out a very cool suite of tools for Blender called \u003ca href=\"https://github.com/chinedufn/landon\"\u003elandon\u003c/a\u003e. Landon makes Blender a source of truth for game engine data. Chinedu\u0026#39;s blog at \u003ca href=\"https://chinedufn.com/\"\u003ehttps://chinedufn.com/\u003c/a\u003e has in-depth development journal posts on his game engine development.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.jameswarlloyd.com/\"\u003eJames Warlloyd\u003c/a\u003e\u003cp\u003eJames created the \u003ca href=\"https://opengameart.org/content/voxel-mech-sniper\"\u003eoriginal mech model\u003c/a\u003e that I used as the bases for the character art in this engine.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eThe state of the art\u003c/h2\u003e\n\u003cp\u003eOverall this project was a significant educational return on investment for me. I learned about hardcore browser optimization and many other data-processing techniques. I have continued to do game ( and engine ) development as a hobby and have already looked into some other emerging technologies. My focus is still on browser multiplayer experiences. I haven\u0026#39;t found the big engines: Unreal, Unity, and Godot have the best models for multiplayer. I have previously written about \u003ca href=\"https://radcade.com/how-to-add-network-multiplayer-to-your-indie-game/\"\u003emultiplayer game engine design for indies\u003c/a\u003e. The big engines use coding patterns that couple game simulation code to rendering code. This coupling makes it challenging to build a server as you have to decouple the simulation and run it headless.\u003c/p\u003e\n\u003cul\u003e\u003cli\u003e\u003ca href=\"https://dotbigbang.com/\"\u003eDotBigBang\u003c/a\u003e\u003cp\u003eDotBigBang is everything this project attempted to be and more. It is a multiplayer voxel 3d engine, all fully in the browser. DotBigBang is focused on user-generated content and is essentially a multiplayer game engine. You can get a group of people together, bring your avatars into a 3D scene, and then collaboratively edit and program that scene like a multiplayer Unity editor experience. I had the fortune to hang with the founder of DotBigBang at GDC 2023 and hear about some impressive browser performance optimization they were doing. He told me about forking Chromium to have better performance debugging visibility into how the JIT compilation and memory usage of the browser was working.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/matrix-org/thirdroom#manifold-engine\"\u003eManifold engine\u003c/a\u003e\u003cp\u003eThe Manifold engine is a stealthy engine currently in development by the \u003ca href=\"https://matrix.org/\"\u003ematrix.org\u003c/a\u003e team. Manifold is embedded in a repository for another project with a disclaimer they might release in the future. The host project is \u0026#39;Thirdroom,\u0026#39; a multiplayer VR metaverse platform.\u003c/p\u003e\n\u003cp\u003eWhen I learned about Manifold I was very excited because it has the same design philosophy and high-performance computation architecture that I had been building towards. It uses Web Workers to create multiple threads to process rendering, physics, and networking separately. All the threads share memory over a \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"\u003eSharedArrayBuffer\u003c/a\u003e, and they use object pooling to reduce garbage collection. Manifold also has WebRTC Data channels for networking. I built a promising prototype in Manifold; unfortunately, Manifold is tightly coupled to a matrix.org backend. The matrix backend has a clunky API to use, which would make custom server-side optimization challenging. If the matrix.org team ever decouples and delivers Manifold, it would be a very compelling option.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/AmbientRun/Ambient\"\u003eAmbient engine\u003c/a\u003e\u003cp\u003eAmbient is a promising new Rust lang engine. It is a default multiplayer engine. It shares code between the client and server. It compiles game code to WASM and then acts as a cross-platform binary runtime to execute that WASM. I have built a promising prototype in Ambient but unfortunately Ambient does not currently make for browser environments. The Ambient team is actively working to target browsers and is aiming for an upcoming release.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","excerpt":"Intro \u0026 TLDR;\nThis post is a retrospective on a multiplayer voxel browser game engine I built. This post will cover the squishy storytelling side of the project, and the accompanying code repository has all of the intricate technical details. This post is essentially a 2 part post. Read this and read the repo README.\n\n  \nDisclaimer\nThis project is a bit old and stale at the time of this post. ...","slug":"2023/04/25/multiplayer-voxel-game-engine","meta":{"keywords":"game dev, javascript, react","image":"img/multiplayer-engine-post/meta.png","description":"I open sourced my HTML5 multiplayer 3D voxel browser game engine.","title":"I built a multiplayer voxel browser game engine. - Kev Zettler"}}},"__N_SSG":true},"page":"/[year]/[month]/[day]/[slug]","query":{"year":"2023","month":"04","day":"25","slug":"multiplayer-voxel-game-engine"},"buildId":"vUyWxDfyKr2O4J8LUYO2n","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>