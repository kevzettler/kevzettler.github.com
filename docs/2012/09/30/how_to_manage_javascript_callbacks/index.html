<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>How To Manage Javascript Callbacks<!-- --> - Kev Zettler</title><meta property="og:image" content="https://kevzettler.com/img/kev.jpeg"/><meta name="description" content="tldr;

Abstract anonymous functions into named functions to avoid nesting callbacks.
Avoid using local variables of a shared scope in nested anonymous functions.
Abstract large JavaScript object declaration into smaller generator functions.

Or &amp;#39;How To Avoid Callback Hell&amp;#39;.
I have been meani"/><meta property="og:description" content="tldr;

Abstract anonymous functions into named functions to avoid nesting callbacks.
Avoid using local variables of a shared scope in nested anonymous functions.
Abstract large JavaScript object declaration into smaller generator functions.

Or &amp;#39;How To Avoid Callback Hell&amp;#39;.
I have been meani"/><meta name="keywords" content="JavaScript,Conventions"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/202bb16ed1cb9668.css" as="style"/><link rel="stylesheet" href="/_next/static/css/202bb16ed1cb9668.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/js/jquery-3.6.4.min.js" defer="" data-nscript="beforeInteractive"></script><script src="/js/vendor/highlight/highlight.min.js" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-3479d0a64c7ffb47.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08ad0149ddcbdd04.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-6fdde5417d1c86e2.js" defer=""></script><script src="/_next/static/ehzWXMFGALfCKdelbNHo7/_buildManifest.js" defer=""></script><script src="/_next/static/ehzWXMFGALfCKdelbNHo7/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><div class="container"><button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="brand" href="/">Kev Zettler</a><div class="nav-collapse collapse"><ul class="nav"><li class=""><a href="/">Blog</a></li><li class=""><a href="/about">About</a></li></ul></div></div></div></div><div class="container" id="body-content"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="post cell"><h1>How To Manage Javascript Callbacks</h1><h4 class="large-bottom">Posted on <!-- -->2012-09-30</h4><div class="content"><h3 id="tldr">tldr;</h3>
<ul>
<li>Abstract anonymous functions into named functions to avoid nesting callbacks.</li>
<li>Avoid using local variables of a shared scope in nested anonymous functions.</li>
<li>Abstract large JavaScript object declaration into smaller generator functions.</li>
</ul>
<h2 id="or-how-to-avoid-callback-hell">Or &#39;How To Avoid Callback Hell&#39;.</h2>
<p>I have been meaning to write this post for some time now. Basically since Node.js came onto the spotlight and people started complaining about JavaScript code maintainability and readability due to
nested callbacks and other asynchronous patterns. This is also highly relevant now with the rise of backbone.js and the discussion for best practices there. Writing JavaScript like Lisp is a bit of an generalization. More specifically, I mean write JavaScript like it’s a functional language, which it is.
By this, I mean write it as small composable functions. I&#39;ll show a few patterns I use that can help keep your JavaScript more manageable. Let’s get into some code examples.</p>
<h2 id="a-standard-jquery-ajax-button-event">A Standard jQuery Ajax Button Event.</h2>
<p>This is fairly common pattern. A button click event triggers an Ajax request. The Ajax request has callbacks for success and error. The success callback triggers another procedure of rendering or possibly another Ajax chain.
The error function does some animation to the button and then does some Ajax to log the error.</p>
<pre><code class="language-javascript">    $(&#39;button&#39;).click(function(event){
      $.ajax({
        url: &quot;http://coolsite.com&quot;
        ,data: {
          &quot;lots&quot; : &quot;of&quot;
          ,&quot;json&quot; : &quot;data&quot;
        }
        ,success: function(data){
          $(&#39;button&#39;).fadeOut(function(){
            alert(&#39;Ajax success!&#39;);
          });
        },
        error: function(data){
          $(&#39;button&#39;).animate({top: &#39;20px&#39;}, function(){
            $.get(&quot;http://coolsite.com/logger&quot;, function(){
               console.log(&#39;error happened&#39;);
            });
        });
        }
      });
    });
</code></pre>
<p>Everything is stuffed into the click handler. All of the Ajax response functions are nested in the scope of the anonymous click handler function.
While this is not necessarily a bad practice, it can promote the growth of unmanageable code.</p>
<p>A familiar scenario, someone might declare a local variable at the top of the click handler declaration and then reference it throughout the nested anonymous functions. This will essentially cause the <code>success</code> and <code>error</code> callbacks to be dependent on their nested position.</p>
<h2 id="how-can-we-make-this-better">How Can We Make This Better?</h2>
<p>Well lets break it up into smaller pieces. More manageable pieces.</p>
<pre><code class="language-javascript">    function ajaxSuccessHandler(data){
      $(&#39;button&#39;).fadeOut(function(){
        alert(&#39;Ajax success!&#39;);
      });
    }

    function ajaxErrorHandler(data){
      $(&#39;button&#39;).animate({top: data.top}, function(){
        $.get(&quot;http://coolsite.com/logger&quot;, function(){
          console.log(&#39;error happened&#39;);
        });
      });
    }

    function buttonClickHandler(event){
      $.ajax({
        url: &quot;http://coolsite.com&quot;
        ,data: {
          &quot;lots&quot;: &quot;of&quot;
          ,&quot;json&quot;: &quot;data&quot;
        }
        ,success: ajaxSuccessHandler
        ,error: ajaxErrorHandler
      });
    }

    $(&#39;button&#39;).click(buttonClickHandler);
</code></pre>
<h2 id="its-okay-to-use-named-functions">Its Okay To Use Named Functions.</h2>
<p>We&#39;ve made a few small abstractions. We&#39;ve moved the anonymous functions that handle the button click, Ajax success, and Ajax error into separate named functions.
Simply giving the anonymous functions names and moving them out of the nested pattern has significantly improved this code.</p>
<p>Visually the code is now easier to parse. The callbacks are now standalone units that can be tested in isolation.
We could easily write a unit test for <code>ajaxSuccessHandler</code> that called it with a dummy data object and ensured it was functioning correctly. This is significantly harder when nesting anonymous functions.</p>
<p>Stack traces now become more useful as well. Trying to hunt down a bug in a stack trace that is 3 layers deep in anonymous functions is not helpful. If the functions are named its much easier to track down issues.</p>
<p>Another added benefit of this pattern is that it now makes it easy to annotate our functions to utilize the features of <a href="https://developers.google.com/closure/compiler/docs/js-for-compiler">Google&#39;s Closure Compiler</a>.
This opens up the opportunity to add strict type checking to our JavaScript.</p>
<p>Expanding on our re-factor, we could have abstracted the anonymous callbacks passed to the <code>fadeOut</code> and <code>animate</code> invocations. Also the callback passed to our <code>$.Get</code> call is ripe for naming as well.
For this small example we&#39;ll skip editing them as its a bit overkill. In larger code bases you&#39;ll see those functions swell.</p>
<h2 id="generate-large-objects-from-named-functions">Generate Large Objects From Named Functions.</h2>
<p>This next example is a bit exaggerated but gets the concept across.
Often times you may have some JavaScript objects defined inline as a parameter or local variable.
In our example, we have the <code>$.ajax</code> method which takes an Object as its parameter and a child object as the <code>data:</code> value.
In our next example code, we abstract these small objects in to some simple named functions that simply return the objects.</p>
<pre><code class="language-javascript">    function ajaxSuccessHandler(data){
      $(&#39;button&#39;).fadeOut(function(){
        alert(&#39;Ajax success!&#39;);
      });
    }

    function ajaxErrorHandler(data){
      $(&#39;button&#39;).animate({top: data.top}, function(){
        $.get(&quot;http://coolsite.com/logger&quot;, function(){
          console.log(&#39;error happened&#39;);
        });
      });
    }

    function buttonClickAjaxData(){
      return {
          &quot;lots&quot;: &quot;of&quot;
          ,&quot;json&quot;: &quot;data&quot;
        };
    }

    function buttonClickAjaxObj(){
      return {
        url: &quot;http://coolsite.com&quot;
        ,data: buttonClickAjaxData()
        ,success: ajaxSuccessHandler
        ,error: ajaxErrorHandler
      };
    }

    function buttonClickHandler(event){
      $.ajax(buttonClickAjaxObj());
    }

    $(&#39;button&#39;).click(buttonClickHandler);
</code></pre>
<p>This abstraction lets us contain the objects in to smaller functions that can be unit tested and managed much easier.
Again this is an exaggerated example and a bit overkill in this case, but definitely useful for larger objects.</p>
<h2 id="just-for-fun">Just For Fun.</h2>
<p>For fun let’s look at the above example in some bad pseudo Lisp.</p>
<blockquote>
<p><strong>Disclaimer</strong> I am by no means a certified Lisper.
The extent of my experience with Lisp is a few toy projects in Scheme and Common Lisp. The following code is meant to be more of visual aid than a functional program.</p>
</blockquote>
<h3 id="our-nested-ajax-procedure">Our Nested Ajax Procedure.</h3>
<p>I&#39;ve simplified <code>success</code> and <code>error</code> callbacks for this example to make them simple calls to <code>alert</code>
You can see this is visually similar to the way JavaScript nests anonymous functions.
This example makes use of Lisps anonymous functions with <code>lambda</code>. <code>lambda</code> is equivalent to JavaScripts <code>(function(){})</code></p>
<pre><code class="language-cl">    (on-click (lambda (event)
      (ajax pseudo-data
        (lambda (data) ; success
          (alert data))
        (lambda (data) ; error
          (alert data)))))
</code></pre>
<h2 id="after-our-re-factor">After Our Re-factor.</h2>
<p>Below you can see that a similar clarity arises to our Lisp code when we abstract the anonymous functions in to named ones.
We now have self-contained small units of code that are much more manageable.</p>
<pre><code class="language-cl">    (defun success-callback (data) (alert data))

    (defun error-callback (data) (jax-log data))

    (defun click-handler (event)
      (ajax pseudo-data success-callback error-callback))

    (on-click click-handler)
</code></pre>
<h2 id="in-conclusion">In Conclusion</h2>
<p>If you&#39;re coming from a traditionally synchronous, procedural programming background. These patterns may not be a silver bullet for you.
This doesn&#39;t eliminate the need for callbacks. Hopefully it will help you manage them better. The code, in parts, is still written and executed in a non-sequential order.</p>
</div><div><hr/><div style="overflow:hidden"><p style="float:left">If you enjoyed this article, consider following me <a href="https://www.twitter.com/kevzettler">on Twitter</a> or <a rel="alternate" type="application/rss+xml" href="/feed.xml">RSS</a></p></div><hr/><div><h2>Comments:</h2><div id="disqus_thread"></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"How To Manage Javascript Callbacks","date":"2012-09-30","contentHTML":"\u003ch3 id=\"tldr\"\u003etldr;\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAbstract anonymous functions into named functions to avoid nesting callbacks.\u003c/li\u003e\n\u003cli\u003eAvoid using local variables of a shared scope in nested anonymous functions.\u003c/li\u003e\n\u003cli\u003eAbstract large JavaScript object declaration into smaller generator functions.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"or-how-to-avoid-callback-hell\"\u003eOr \u0026#39;How To Avoid Callback Hell\u0026#39;.\u003c/h2\u003e\n\u003cp\u003eI have been meaning to write this post for some time now. Basically since Node.js came onto the spotlight and people started complaining about JavaScript code maintainability and readability due to\nnested callbacks and other asynchronous patterns. This is also highly relevant now with the rise of backbone.js and the discussion for best practices there. Writing JavaScript like Lisp is a bit of an generalization. More specifically, I mean write JavaScript like it’s a functional language, which it is.\nBy this, I mean write it as small composable functions. I\u0026#39;ll show a few patterns I use that can help keep your JavaScript more manageable. Let’s get into some code examples.\u003c/p\u003e\n\u003ch2 id=\"a-standard-jquery-ajax-button-event\"\u003eA Standard jQuery Ajax Button Event.\u003c/h2\u003e\n\u003cp\u003eThis is fairly common pattern. A button click event triggers an Ajax request. The Ajax request has callbacks for success and error. The success callback triggers another procedure of rendering or possibly another Ajax chain.\nThe error function does some animation to the button and then does some Ajax to log the error.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e    $(\u0026#39;button\u0026#39;).click(function(event){\n      $.ajax({\n        url: \u0026quot;http://coolsite.com\u0026quot;\n        ,data: {\n          \u0026quot;lots\u0026quot; : \u0026quot;of\u0026quot;\n          ,\u0026quot;json\u0026quot; : \u0026quot;data\u0026quot;\n        }\n        ,success: function(data){\n          $(\u0026#39;button\u0026#39;).fadeOut(function(){\n            alert(\u0026#39;Ajax success!\u0026#39;);\n          });\n        },\n        error: function(data){\n          $(\u0026#39;button\u0026#39;).animate({top: \u0026#39;20px\u0026#39;}, function(){\n            $.get(\u0026quot;http://coolsite.com/logger\u0026quot;, function(){\n               console.log(\u0026#39;error happened\u0026#39;);\n            });\n        });\n        }\n      });\n    });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEverything is stuffed into the click handler. All of the Ajax response functions are nested in the scope of the anonymous click handler function.\nWhile this is not necessarily a bad practice, it can promote the growth of unmanageable code.\u003c/p\u003e\n\u003cp\u003eA familiar scenario, someone might declare a local variable at the top of the click handler declaration and then reference it throughout the nested anonymous functions. This will essentially cause the \u003ccode\u003esuccess\u003c/code\u003e and \u003ccode\u003eerror\u003c/code\u003e callbacks to be dependent on their nested position.\u003c/p\u003e\n\u003ch2 id=\"how-can-we-make-this-better\"\u003eHow Can We Make This Better?\u003c/h2\u003e\n\u003cp\u003eWell lets break it up into smaller pieces. More manageable pieces.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e    function ajaxSuccessHandler(data){\n      $(\u0026#39;button\u0026#39;).fadeOut(function(){\n        alert(\u0026#39;Ajax success!\u0026#39;);\n      });\n    }\n\n    function ajaxErrorHandler(data){\n      $(\u0026#39;button\u0026#39;).animate({top: data.top}, function(){\n        $.get(\u0026quot;http://coolsite.com/logger\u0026quot;, function(){\n          console.log(\u0026#39;error happened\u0026#39;);\n        });\n      });\n    }\n\n    function buttonClickHandler(event){\n      $.ajax({\n        url: \u0026quot;http://coolsite.com\u0026quot;\n        ,data: {\n          \u0026quot;lots\u0026quot;: \u0026quot;of\u0026quot;\n          ,\u0026quot;json\u0026quot;: \u0026quot;data\u0026quot;\n        }\n        ,success: ajaxSuccessHandler\n        ,error: ajaxErrorHandler\n      });\n    }\n\n    $(\u0026#39;button\u0026#39;).click(buttonClickHandler);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"its-okay-to-use-named-functions\"\u003eIts Okay To Use Named Functions.\u003c/h2\u003e\n\u003cp\u003eWe\u0026#39;ve made a few small abstractions. We\u0026#39;ve moved the anonymous functions that handle the button click, Ajax success, and Ajax error into separate named functions.\nSimply giving the anonymous functions names and moving them out of the nested pattern has significantly improved this code.\u003c/p\u003e\n\u003cp\u003eVisually the code is now easier to parse. The callbacks are now standalone units that can be tested in isolation.\nWe could easily write a unit test for \u003ccode\u003eajaxSuccessHandler\u003c/code\u003e that called it with a dummy data object and ensured it was functioning correctly. This is significantly harder when nesting anonymous functions.\u003c/p\u003e\n\u003cp\u003eStack traces now become more useful as well. Trying to hunt down a bug in a stack trace that is 3 layers deep in anonymous functions is not helpful. If the functions are named its much easier to track down issues.\u003c/p\u003e\n\u003cp\u003eAnother added benefit of this pattern is that it now makes it easy to annotate our functions to utilize the features of \u003ca href=\"https://developers.google.com/closure/compiler/docs/js-for-compiler\"\u003eGoogle\u0026#39;s Closure Compiler\u003c/a\u003e.\nThis opens up the opportunity to add strict type checking to our JavaScript.\u003c/p\u003e\n\u003cp\u003eExpanding on our re-factor, we could have abstracted the anonymous callbacks passed to the \u003ccode\u003efadeOut\u003c/code\u003e and \u003ccode\u003eanimate\u003c/code\u003e invocations. Also the callback passed to our \u003ccode\u003e$.Get\u003c/code\u003e call is ripe for naming as well.\nFor this small example we\u0026#39;ll skip editing them as its a bit overkill. In larger code bases you\u0026#39;ll see those functions swell.\u003c/p\u003e\n\u003ch2 id=\"generate-large-objects-from-named-functions\"\u003eGenerate Large Objects From Named Functions.\u003c/h2\u003e\n\u003cp\u003eThis next example is a bit exaggerated but gets the concept across.\nOften times you may have some JavaScript objects defined inline as a parameter or local variable.\nIn our example, we have the \u003ccode\u003e$.ajax\u003c/code\u003e method which takes an Object as its parameter and a child object as the \u003ccode\u003edata:\u003c/code\u003e value.\nIn our next example code, we abstract these small objects in to some simple named functions that simply return the objects.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e    function ajaxSuccessHandler(data){\n      $(\u0026#39;button\u0026#39;).fadeOut(function(){\n        alert(\u0026#39;Ajax success!\u0026#39;);\n      });\n    }\n\n    function ajaxErrorHandler(data){\n      $(\u0026#39;button\u0026#39;).animate({top: data.top}, function(){\n        $.get(\u0026quot;http://coolsite.com/logger\u0026quot;, function(){\n          console.log(\u0026#39;error happened\u0026#39;);\n        });\n      });\n    }\n\n    function buttonClickAjaxData(){\n      return {\n          \u0026quot;lots\u0026quot;: \u0026quot;of\u0026quot;\n          ,\u0026quot;json\u0026quot;: \u0026quot;data\u0026quot;\n        };\n    }\n\n    function buttonClickAjaxObj(){\n      return {\n        url: \u0026quot;http://coolsite.com\u0026quot;\n        ,data: buttonClickAjaxData()\n        ,success: ajaxSuccessHandler\n        ,error: ajaxErrorHandler\n      };\n    }\n\n    function buttonClickHandler(event){\n      $.ajax(buttonClickAjaxObj());\n    }\n\n    $(\u0026#39;button\u0026#39;).click(buttonClickHandler);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis abstraction lets us contain the objects in to smaller functions that can be unit tested and managed much easier.\nAgain this is an exaggerated example and a bit overkill in this case, but definitely useful for larger objects.\u003c/p\u003e\n\u003ch2 id=\"just-for-fun\"\u003eJust For Fun.\u003c/h2\u003e\n\u003cp\u003eFor fun let’s look at the above example in some bad pseudo Lisp.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eDisclaimer\u003c/strong\u003e I am by no means a certified Lisper.\nThe extent of my experience with Lisp is a few toy projects in Scheme and Common Lisp. The following code is meant to be more of visual aid than a functional program.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"our-nested-ajax-procedure\"\u003eOur Nested Ajax Procedure.\u003c/h3\u003e\n\u003cp\u003eI\u0026#39;ve simplified \u003ccode\u003esuccess\u003c/code\u003e and \u003ccode\u003eerror\u003c/code\u003e callbacks for this example to make them simple calls to \u003ccode\u003ealert\u003c/code\u003e\nYou can see this is visually similar to the way JavaScript nests anonymous functions.\nThis example makes use of Lisps anonymous functions with \u003ccode\u003elambda\u003c/code\u003e. \u003ccode\u003elambda\u003c/code\u003e is equivalent to JavaScripts \u003ccode\u003e(function(){})\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cl\"\u003e    (on-click (lambda (event)\n      (ajax pseudo-data\n        (lambda (data) ; success\n          (alert data))\n        (lambda (data) ; error\n          (alert data)))))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"after-our-re-factor\"\u003eAfter Our Re-factor.\u003c/h2\u003e\n\u003cp\u003eBelow you can see that a similar clarity arises to our Lisp code when we abstract the anonymous functions in to named ones.\nWe now have self-contained small units of code that are much more manageable.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cl\"\u003e    (defun success-callback (data) (alert data))\n\n    (defun error-callback (data) (jax-log data))\n\n    (defun click-handler (event)\n      (ajax pseudo-data success-callback error-callback))\n\n    (on-click click-handler)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"in-conclusion\"\u003eIn Conclusion\u003c/h2\u003e\n\u003cp\u003eIf you\u0026#39;re coming from a traditionally synchronous, procedural programming background. These patterns may not be a silver bullet for you.\nThis doesn\u0026#39;t eliminate the need for callbacks. Hopefully it will help you manage them better. The code, in parts, is still written and executed in a non-sequential order.\u003c/p\u003e\n","excerpt":"tldr;\n\nAbstract anonymous functions into named functions to avoid nesting callbacks.\nAvoid using local variables of a shared scope in nested anonymous functions.\nAbstract large JavaScript object declaration into smaller generator functions.\n\nOr 'How To Avoid Callback Hell'.\nI have been mea...","slug":"2012/09/30/how_to_manage_javascript_callbacks","meta":{"keywords":["JavaScript","Conventions"],"image":"img/kev.jpeg","description":"tldr;\n\nAbstract anonymous functions into named functions to avoid nesting callbacks.\nAvoid using local variables of a shared scope in nested anonymous functions.\nAbstract large JavaScript object declaration into smaller generator functions.\n\nOr \u0026#39;How To Avoid Callback Hell\u0026#39;.\nI have been meani"}}},"__N_SSG":true},"page":"/[year]/[month]/[day]/[slug]","query":{"year":"2012","month":"09","day":"30","slug":"how_to_manage_javascript_callbacks"},"buildId":"ehzWXMFGALfCKdelbNHo7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>