{"pageProps":{"post":{"title":"How To Manage Javascript Callbacks","date":"2012-09-30","contentHTML":"<h3 id=\"tldr\">tldr;</h3>\n<ul>\n<li>Abstract anonymous functions into named functions to avoid nesting callbacks.</li>\n<li>Avoid using local variables of a shared scope in nested anonymous functions.</li>\n<li>Abstract large JavaScript object declaration into smaller generator functions.</li>\n</ul>\n<h2 id=\"or-how-to-avoid-callback-hell\">Or &#39;How To Avoid Callback Hell&#39;.</h2>\n<p>I have been meaning to write this post for some time now. Basically since Node.js came onto the spotlight and people started complaining about JavaScript code maintainability and readability due to\nnested callbacks and other asynchronous patterns. This is also highly relevant now with the rise of backbone.js and the discussion for best practices there. Writing JavaScript like Lisp is a bit of an generalization. More specifically, I mean write JavaScript like it’s a functional language, which it is.\nBy this, I mean write it as small composable functions. I&#39;ll show a few patterns I use that can help keep your JavaScript more manageable. Let’s get into some code examples.</p>\n<h2 id=\"a-standard-jquery-ajax-button-event\">A Standard jQuery Ajax Button Event.</h2>\n<p>This is fairly common pattern. A button click event triggers an Ajax request. The Ajax request has callbacks for success and error. The success callback triggers another procedure of rendering or possibly another Ajax chain.\nThe error function does some animation to the button and then does some Ajax to log the error.</p>\n<pre><code class=\"language-javascript\">    $(&#39;button&#39;).click(function(event){\n      $.ajax({\n        url: &quot;http://coolsite.com&quot;\n        ,data: {\n          &quot;lots&quot; : &quot;of&quot;\n          ,&quot;json&quot; : &quot;data&quot;\n        }\n        ,success: function(data){\n          $(&#39;button&#39;).fadeOut(function(){\n            alert(&#39;Ajax success!&#39;);\n          });\n        },\n        error: function(data){\n          $(&#39;button&#39;).animate({top: &#39;20px&#39;}, function(){\n            $.get(&quot;http://coolsite.com/logger&quot;, function(){\n               console.log(&#39;error happened&#39;);\n            });\n        });\n        }\n      });\n    });\n</code></pre>\n<p>Everything is stuffed into the click handler. All of the Ajax response functions are nested in the scope of the anonymous click handler function.\nWhile this is not necessarily a bad practice, it can promote the growth of unmanageable code.</p>\n<p>A familiar scenario, someone might declare a local variable at the top of the click handler declaration and then reference it throughout the nested anonymous functions. This will essentially cause the <code>success</code> and <code>error</code> callbacks to be dependent on their nested position.</p>\n<h2 id=\"how-can-we-make-this-better\">How Can We Make This Better?</h2>\n<p>Well lets break it up into smaller pieces. More manageable pieces.</p>\n<pre><code class=\"language-javascript\">    function ajaxSuccessHandler(data){\n      $(&#39;button&#39;).fadeOut(function(){\n        alert(&#39;Ajax success!&#39;);\n      });\n    }\n\n    function ajaxErrorHandler(data){\n      $(&#39;button&#39;).animate({top: data.top}, function(){\n        $.get(&quot;http://coolsite.com/logger&quot;, function(){\n          console.log(&#39;error happened&#39;);\n        });\n      });\n    }\n\n    function buttonClickHandler(event){\n      $.ajax({\n        url: &quot;http://coolsite.com&quot;\n        ,data: {\n          &quot;lots&quot;: &quot;of&quot;\n          ,&quot;json&quot;: &quot;data&quot;\n        }\n        ,success: ajaxSuccessHandler\n        ,error: ajaxErrorHandler\n      });\n    }\n\n    $(&#39;button&#39;).click(buttonClickHandler);\n</code></pre>\n<h2 id=\"its-okay-to-use-named-functions\">Its Okay To Use Named Functions.</h2>\n<p>We&#39;ve made a few small abstractions. We&#39;ve moved the anonymous functions that handle the button click, Ajax success, and Ajax error into separate named functions.\nSimply giving the anonymous functions names and moving them out of the nested pattern has significantly improved this code.</p>\n<p>Visually the code is now easier to parse. The callbacks are now standalone units that can be tested in isolation.\nWe could easily write a unit test for <code>ajaxSuccessHandler</code> that called it with a dummy data object and ensured it was functioning correctly. This is significantly harder when nesting anonymous functions.</p>\n<p>Stack traces now become more useful as well. Trying to hunt down a bug in a stack trace that is 3 layers deep in anonymous functions is not helpful. If the functions are named its much easier to track down issues.</p>\n<p>Another added benefit of this pattern is that it now makes it easy to annotate our functions to utilize the features of <a href=\"https://developers.google.com/closure/compiler/docs/js-for-compiler\">Google&#39;s Closure Compiler</a>.\nThis opens up the opportunity to add strict type checking to our JavaScript.</p>\n<p>Expanding on our re-factor, we could have abstracted the anonymous callbacks passed to the <code>fadeOut</code> and <code>animate</code> invocations. Also the callback passed to our <code>$.Get</code> call is ripe for naming as well.\nFor this small example we&#39;ll skip editing them as its a bit overkill. In larger code bases you&#39;ll see those functions swell.</p>\n<h2 id=\"generate-large-objects-from-named-functions\">Generate Large Objects From Named Functions.</h2>\n<p>This next example is a bit exaggerated but gets the concept across.\nOften times you may have some JavaScript objects defined inline as a parameter or local variable.\nIn our example, we have the <code>$.ajax</code> method which takes an Object as its parameter and a child object as the <code>data:</code> value.\nIn our next example code, we abstract these small objects in to some simple named functions that simply return the objects.</p>\n<pre><code class=\"language-javascript\">    function ajaxSuccessHandler(data){\n      $(&#39;button&#39;).fadeOut(function(){\n        alert(&#39;Ajax success!&#39;);\n      });\n    }\n\n    function ajaxErrorHandler(data){\n      $(&#39;button&#39;).animate({top: data.top}, function(){\n        $.get(&quot;http://coolsite.com/logger&quot;, function(){\n          console.log(&#39;error happened&#39;);\n        });\n      });\n    }\n\n    function buttonClickAjaxData(){\n      return {\n          &quot;lots&quot;: &quot;of&quot;\n          ,&quot;json&quot;: &quot;data&quot;\n        };\n    }\n\n    function buttonClickAjaxObj(){\n      return {\n        url: &quot;http://coolsite.com&quot;\n        ,data: buttonClickAjaxData()\n        ,success: ajaxSuccessHandler\n        ,error: ajaxErrorHandler\n      };\n    }\n\n    function buttonClickHandler(event){\n      $.ajax(buttonClickAjaxObj());\n    }\n\n    $(&#39;button&#39;).click(buttonClickHandler);\n</code></pre>\n<p>This abstraction lets us contain the objects in to smaller functions that can be unit tested and managed much easier.\nAgain this is an exaggerated example and a bit overkill in this case, but definitely useful for larger objects.</p>\n<h2 id=\"just-for-fun\">Just For Fun.</h2>\n<p>For fun let’s look at the above example in some bad pseudo Lisp.</p>\n<blockquote>\n<p><strong>Disclaimer</strong> I am by no means a certified Lisper.\nThe extent of my experience with Lisp is a few toy projects in Scheme and Common Lisp. The following code is meant to be more of visual aid than a functional program.</p>\n</blockquote>\n<h3 id=\"our-nested-ajax-procedure\">Our Nested Ajax Procedure.</h3>\n<p>I&#39;ve simplified <code>success</code> and <code>error</code> callbacks for this example to make them simple calls to <code>alert</code>\nYou can see this is visually similar to the way JavaScript nests anonymous functions.\nThis example makes use of Lisps anonymous functions with <code>lambda</code>. <code>lambda</code> is equivalent to JavaScripts <code>(function(){})</code></p>\n<pre><code class=\"language-cl\">    (on-click (lambda (event)\n      (ajax pseudo-data\n        (lambda (data) ; success\n          (alert data))\n        (lambda (data) ; error\n          (alert data)))))\n</code></pre>\n<h2 id=\"after-our-re-factor\">After Our Re-factor.</h2>\n<p>Below you can see that a similar clarity arises to our Lisp code when we abstract the anonymous functions in to named ones.\nWe now have self-contained small units of code that are much more manageable.</p>\n<pre><code class=\"language-cl\">    (defun success-callback (data) (alert data))\n\n    (defun error-callback (data) (jax-log data))\n\n    (defun click-handler (event)\n      (ajax pseudo-data success-callback error-callback))\n\n    (on-click click-handler)\n</code></pre>\n<h2 id=\"in-conclusion\">In Conclusion</h2>\n<p>If you&#39;re coming from a traditionally synchronous, procedural programming background. These patterns may not be a silver bullet for you.\nThis doesn&#39;t eliminate the need for callbacks. Hopefully it will help you manage them better. The code, in parts, is still written and executed in a non-sequential order.</p>\n","excerpt":"tldr;\n\nAbstract anonymous functions into named functions to avoid nesting callbacks.\nAvoid using local variables of a shared scope in nested anonymous functions.\nAbstract large JavaScript object declaration into smaller generator functions.\n\nOr 'How To Avoid Callback Hell'.\nI have been mea...","slug":"2012/09/30/how_to_manage_javascript_callbacks","meta":{"title":"How To Manage Javascript Callbacks","keywords":["JavaScript","Conventions"],"image":"img/kev.jpeg","description":"tldr;\n\nAbstract anonymous functions into named functions to avoid nesting callbacks.\nAvoid using local variables of a shared scope in nested anonymous functions.\nAbstract large JavaScript object declaration into smaller generator functions.\n\nOr &#39;How To Avoid Callback Hell&#39;.\nI have been meani"}}},"__N_SSG":true}