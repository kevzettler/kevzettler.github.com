<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Rapid Local Development with Vagrant, Docker and Node.js<!-- --> - Kev Zettler</title><meta property="og:title" content="Rapid Local Development with Vagrant, Docker and Node.js - Kev Zettler"/><meta property="og:image" content="https://kevzettler.com/img/kev.jpeg"/><meta name="description" content="TLDR

Using a cascade of Vagrant shared directories, Docker volumes and cleverly placed symlinks, you can rig Vagrant and Docker to instantly reflect your local application code updates.
Docker volume -&amp;gt; Vagrant shared directory -&amp;gt; Host machine code.
Enable NPM link style development in Docker"/><meta property="og:description" content="TLDR

Using a cascade of Vagrant shared directories, Docker volumes and cleverly placed symlinks, you can rig Vagrant and Docker to instantly reflect your local application code updates.
Docker volume -&amp;gt; Vagrant shared directory -&amp;gt; Host machine code.
Enable NPM link style development in Docker"/><meta name="keywords" content="JavaScript,Conventions,Docker,Vagrant,Node.js"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@kevzettler"/><meta name="twitter:creator" content="@kevzettler"/><meta name="twitter:title" content="Rapid Local Development with Vagrant, Docker and Node.js - Kev Zettler"/><meta name="twitter:description" content="TLDR

Using a cascade of Vagrant shared directories, Docker volumes and cleverly placed symlinks, you can rig Vagrant and Docker to instantly reflect your local application code updates.
Docker volume -&amp;gt; Vagrant shared directory -&amp;gt; Host machine code.
Enable NPM link style development in Docker"/><meta name="twitter:image" content="https://kevzettler.com/img/kev.jpeg"/><meta name="twitter:image:width" content="4096"/><meta name="twitter:image:height" content="2701"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/5bc2ebe57d9765ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5bc2ebe57d9765ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/js/jquery-3.6.4.min.js" defer="" data-nscript="beforeInteractive"></script><script src="/js/vendor/highlight/highlight.min.js" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-3479d0a64c7ffb47.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08ad0149ddcbdd04.js" defer=""></script><script src="/_next/static/chunks/189-d94bf35bddc387ba.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-92d8d79e257662e4.js" defer=""></script><script src="/_next/static/4DEA3N0-2m_VOpUDOWqKG/_buildManifest.js" defer=""></script><script src="/_next/static/4DEA3N0-2m_VOpUDOWqKG/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><div class="container"><button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="brand" href="/">Kev Zettler</a><div class="nav-collapse collapse"><ul class="nav"><li class=""><a href="/">Blog</a></li><li class=""><a href="/about">About</a></li></ul></div></div></div></div><div class="container" id="body-content"><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="post cell"><h1>Rapid Local Development with Vagrant, Docker and Node.js</h1><h4 class="large-bottom">Posted on <!-- -->2015-06-07</h4><div class="content"><h3 id="tldr">TLDR</h3>
<ul>
<li>Using a cascade of Vagrant shared directories, Docker volumes and cleverly placed symlinks, you can rig Vagrant and Docker to instantly reflect your local application code updates.</li>
<li>Docker volume -&gt; Vagrant shared directory -&gt; Host machine code.</li>
<li>Enable NPM link style development in Docker container.</li>
<li>Dosen&#x27;t cover <code>gulp</code> <code>webpack</code> asset generation but you can figure it out.</li>
<li>There might be a better way to do this or improvements to make. Leave it in the comments.</li>
</ul>
<h2 id="the-problem">The Problem</h2>
<p>I wanted to use <a href="https://github.com/js-platform/node-webrtc" target="_blank" rel="noopener noreferrer">isomorphic WebRTC</a> with the awesome <a href="https://github.com/feross/simple-peer" target="_blank" rel="noopener noreferrer">SimplePeer</a> in a recent Node.js project. However the server WebRTC has a bunch of system level dependencies that are a pain to install. Luckily they provide a <a href="https://github.com/js-platform/node-webrtc/blob/develop/Dockerfile" target="_blank" rel="noopener noreferrer">Dockerfile</a> which does it all for you. I didn&#x27;t end up using their exact Dockerfile but copy pasted the majority of it to my project to use as a <code>Base web</code> Dockerfile.</p>
<p>I also wanted to do development on a custom Node module. Usually on your local machine you would do <code>npm link</code> which creates a symlink to your module&#x27;s code directory and you can rapidly iterate there. However, working with Vagrant and Docker makes this more complicated.</p>
<p>I wanted all this to work without having to rebuild Docker images, rerun docker containers, or reprovision Vagrant.</p>
<h2 id="the-base-web-image">The Base Web Image</h2>
<pre><code class="language-docker"># baseweb Dockerfile
FROM ubuntu:14.04

ENV DEBIAN_FRONTEND noninteractive
RUN echo debconf shared/accepted-oracle-license-v1-1 select true | debconf-set-selections
RUN echo debconf shared/accepted-oracle-license-v1-1 seen true | debconf-set-selections

RUN apt-get update &amp;&amp; apt-get install -y software-properties-common
RUN add-apt-repository ppa:webupd8team/java &amp;&amp; add-apt-repository ppa:chris-lea/node.js &amp;&amp; apt-get update

RUN apt-get install -y git subversion g++ python libnss3-dev libasound2-dev libpulse-dev \
libjpeg62-dev libxv-dev libgtk2.0-dev libexpat1-dev libxss-dev libudev-dev libdrm-dev libgconf2-dev \
libgcrypt11-dev libpci-dev libxtst-dev libgnome-keyring-dev libssl-dev nodejs oracle-java6-installer oracle-java6-set-default

ENV JAVA_HOME /usr/lib/jvm/java-6-oracle/
ENV PATH $PATH:/usr/lib/jvm/java-6-oracle/jre/bin/


RUN npm install -g forever
</code></pre>
<p>With the <code>BaseWeb</code> Dockerfile inplace I then have my Nodejs application. It&#x27;s structured as follows.</p>
<h2 id="the-web-application-code">The Web Application Code</h2>
<pre><code class="language-bash">/Projects/demo/web
├── Dockerfile
├── index.js
├── node_modules -&gt; /dist/node_modules/
└── package.json
</code></pre>
<p>Take note here that my <code>node_modules</code> is actually a symlink to <code>/dist/node_modules/</code> this is committed to my repo. This may seem odd but it&#x27;s key to letting us rapidly develop on a custom module. It enables a <code>npm link</code> style work flow.</p>
<h3 id="the-vagrant-setup">The Vagrant Setup</h3>
<p>Assume we have a Vagrantfile outside of our web project like so:</p>
<pre><code class="language-bash">/Projects/demo/
├── Vagrantfile
└── web
</code></pre>
<p>This will automatically mount the web code as a shared directory inside the Vagrant machine at <code>/vagrant/web</code>. At this point we can <code>vagrant up</code> and edit the application code on the host machine as usual and Vagrant will pickup the changes. This dosen&#x27;t help us yet because the code is dependent on the ismorphic WebRTC dependences. We need Vagrant to run the Docker containers.</p>
<p>Before we get to the <code>Vagrantfile</code> let&#x27;s look at the Web Applications&#x27; Dockerfile.</p>
<h2 id="the-web-application-dockerfile">The Web Application Dockerfile</h2>
<pre><code class="language-dockerfile"># web DockerFile
FROM base_web
COPY package.json /dist/package.json
RUN mkdir /dist/node_modules &amp;&amp; cd /dist &amp;&amp; npm install
ADD . /srv/www
RUN ln -s /dist/node_modules /srv/www/node_modules
WORKDIR /srv/www
EXPOSE 5000
CMD [&quot;forever&quot;, &quot;index.js&quot;]
</code></pre>
<h4 id="points-of-interest">Points Of Interest</h4>
<ul>
<li><p>The key to this whole thing here is the <code>node_modules</code> setup. We don&#x27;t do the <code>npm install</code> in the application code directory. We create a <code>/dist/</code> directory and copy <code>package.json</code> there. We then <code>npm install</code> in <code>/dist</code> and get <code>/dist/node_modules</code>. This is really the seceret sauce. In production you don’t rebuild your modules each time you re-build your container. If your <code>package.json</code> file changes then your modules will be rebuilt. I got this from  <a href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/" target="_blank" rel="noopener noreferrer">Building Efficient Dockerfiles</a></p>
</li>
<li><p><code>RUN ln -s /dist/node_modules /srv/www/node_modules</code></p>
<p> This creates a symlink for <code>node_modues</code> from our application code at <code>/srv/www</code>. to our <code>/dist</code>. This also overrides the symlink that is committed in the web repo. You might be thinking, &quot;well what was the point of that then?&quot;. I promise we&#x27;ll get to that soon. It&#x27;s key to the <code>npm link</code> style.</p>
</li>
</ul>
<h3 id="the-vagrant-file">The Vagrant File</h3>
<pre><code class="language-ruby">Vagrant.configure(2) do |config|
  config.vm.box = &quot;Ubuntu 14.04 with Docker enabled&quot;
  config.vm.box_url = &quot;https://github.com/jose-lpa/packer-ubuntu_14.04/releases/download/v2.0/ubuntu-14.04.box&quot;

  config.vm.provision &quot;docker&quot; do |d|
    d.build_image &quot;/vagrant/Dockerfiles/base_web&quot;, args: &#x27;-t &quot;base_web&quot;&#x27;
    d.build_image &quot;/vagrant/web&quot;, args: &#x27;-t &quot;web&quot;&#x27;

    d.run &quot;web&quot;,
          cmd: &quot;forever -w bin/server.js&quot;,
          args: &quot;-v &#x27;/vagrant/web:/srv/www&#x27;\
                 -e NODE_ENV=development\
                 -p 5000:5000&quot;
  end

  config.vm.network &quot;forwarded_port&quot;, guest: 5000, host: 5000
end
</code></pre>
<h4 id="points-of-interest-1">Points of interest</h4>
<ul>
<li>We use a &#x27;Docker enabled&#x27; image for our Docker box.</li>
<li>We use Vagrant&#x27;s built-in Docker provisioner.</li>
<li>We then run our container with some new arguments.</li>
</ul>
<p>Let&#x27;s look at the run command more in-depth.</p>
<pre><code class="language-ruby">    d.run &quot;web&quot;,
          cmd: &quot;forever -w index.js&quot;,
          args: &quot;-v &#x27;/vagrant/web:/srv/www&#x27;\
                 -e NODE_ENV=development\
                 -p 5000:5000&quot;
</code></pre>
<p>We&#x27;re overriding the Dockerfiles&#x27; <code>CMD [&quot;forever&quot;, &quot;index.js&quot;]</code> with <code>forever -w index.js</code> The <code>-w</code> flag restarts our server on code updates, which is what we want in a development environment.</p>
<h3 id="bringing-it-all-together">Bringing It All Together</h3>
<p>The Most important part of the <code>docker run</code> options is the <code>-v</code> flag, which is for Docker Volumes. We are telling our container to mount <code>/srv/www</code> as a volume that points to <code>/vagrant/web/</code>. If you review our Vagrant setup from earlier you can see that <code>/srv/www</code> is actualy a shared directory to our application code directory <code>/web</code> on the host machine!</p>
<p>A quick diagram of this shared filesystem cascade looks like this:</p>
<pre><code class="language-bash">Docker `/srv/www` -&gt;
Vagrant `/vagrant/web -&gt;
Host `/web`/
</code></pre>
<p>At this point you&#x27;re set up to rapidly develop on your application code and have updates reflected in your Docker container.</p>
<p>The next challenge I faced was figuring out how to handle a local NPM module dependency that I wanted to iterate on in the same rapid manner.</p>
<h2 id="npm-link-development-in-a-docker-container">NPM Link Development In A Docker Container</h2>
<p>So in this scenario. Lets assume that <code>web</code> has an entry in <code>package.json</code> like this:</p>
<pre><code class="language-json">  &quot;dependencies&quot;: {
   &quot;customModule&quot;: &quot;git://github.com/kevzettler/customModule&quot;,
   }
</code></pre>
<p><code>customModule</code> is a NPM module that we maintain and develop. This package.json setup works fine for production because we just install from the repo and forget about it. In development we want to rapidly make changes to <code>customModule</code>and not have to rebuild everything. Normally when developing on local machine, we would <code>cd</code> into <code>web</code> and do <code>npm link customModule</code> which would build a symlink to our <code>customModule</code> code that would give us a rapid development setup.</p>
<p>When we add Vagrant and Docker to the dev environment, this completly breaks NPM Link.</p>
<p>Here&#x27;s an updated directory diagram of our project with the new <code>customModule</code> code:</p>
<pre><code class="language-bash">/Projects/demo/
├── Vagrantfile
├── web
└── customModule
</code></pre>
<p>So similliar to the web code, Vagrant will mount our customModule code at <code>/vagrant/customModule</code></p>
<p>We can then update our VagrantFile to add a new Docker Volume:
<code>-v &#x27;/vagrant/engine:/dist/node_modules/engine&#x27;</code></p>
<pre><code class="language-ruby">    d.run &quot;web&quot;,
          cmd: &quot;forever -w index.js&quot;,
          args: &quot;-v &#x27;/vagrant/web:/srv/www&#x27;\
                 -v &#x27;/vagrant/customModule:/dist/node_modules/customModule&#x27;\
                 -e NODE_ENV=development\
                 -p 5000:5000&quot;
</code></pre>
<h3 id="whats-all-this-symlink-business-then">What&#x27;s All This Symlink Business Then?</h3>
<p>So we have this symlink in 2 places.</p>
<ul>
<li><p>The <code>RUN</code> symlink in Web Dockerfile
  <code>RUN ln -s /dist/node_modules /srv/www/node_modules</code></p>
</li>
<li><p>In &#x27;Filesystem&#x27; symlink
  <code>node_modules -&gt; /dist/node_modules/</code></p>
</li>
</ul>
<p>Docker does not support symlinks when using the <code>ADD</code> command in a DockerFile.
It will drop them from the <code>ADD</code> filesystem. That&#x27;s why we need the <code>RUN</code> symlink in the dockerfile.</p>
<p>When we want to do development work, we run the container with the <code>-v</code> flag to mount our local code. The volume doesn&#x27;t get attached until after our container has already been created. At that time, the <code>RUN</code> symlink exists; however, the <code>-v</code> option overrides everything in the container&#x27;s <code>/srv/www/</code>, wiping out the <code>RUN</code> symlink.</p>
<p>But wait! We have a &#x27;Filesystem&#x27; symlink in our shared code. The volume respects this symlink and it routes internally to the container&#x27;s filesystem. You don&#x27;t necessarily have to commit the symlink to your repo like I was dong. You just need it around when you build the Docker image. I committed it because I kept forgetting. Try this out and let me know if you have a better solution to it.</p>
</div><div><hr/><div style="overflow:hidden"><p style="float:left">If you enjoyed this article, consider following me <a href="https://www.twitter.com/kevzettler">on Twitter</a></p></div><hr/><div><h2>Comments:</h2><div id="disqus_thread"></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Rapid Local Development with Vagrant, Docker and Node.js","date":"2015-06-07","contentHTML":"\u003ch3 id=\"tldr\"\u003eTLDR\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eUsing a cascade of Vagrant shared directories, Docker volumes and cleverly placed symlinks, you can rig Vagrant and Docker to instantly reflect your local application code updates.\u003c/li\u003e\n\u003cli\u003eDocker volume -\u0026gt; Vagrant shared directory -\u0026gt; Host machine code.\u003c/li\u003e\n\u003cli\u003eEnable NPM link style development in Docker container.\u003c/li\u003e\n\u003cli\u003eDosen\u0026#39;t cover \u003ccode\u003egulp\u003c/code\u003e \u003ccode\u003ewebpack\u003c/code\u003e asset generation but you can figure it out.\u003c/li\u003e\n\u003cli\u003eThere might be a better way to do this or improvements to make. Leave it in the comments.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"the-problem\"\u003eThe Problem\u003c/h2\u003e\n\u003cp\u003eI wanted to use \u003ca href=\"https://github.com/js-platform/node-webrtc\"\u003eisomorphic WebRTC\u003c/a\u003e with the awesome \u003ca href=\"https://github.com/feross/simple-peer\"\u003eSimplePeer\u003c/a\u003e in a recent Node.js project. However the server WebRTC has a bunch of system level dependencies that are a pain to install. Luckily they provide a \u003ca href=\"https://github.com/js-platform/node-webrtc/blob/develop/Dockerfile\"\u003eDockerfile\u003c/a\u003e which does it all for you. I didn\u0026#39;t end up using their exact Dockerfile but copy pasted the majority of it to my project to use as a \u003ccode\u003eBase web\u003c/code\u003e Dockerfile.\u003c/p\u003e\n\u003cp\u003eI also wanted to do development on a custom Node module. Usually on your local machine you would do \u003ccode\u003enpm link\u003c/code\u003e which creates a symlink to your module\u0026#39;s code directory and you can rapidly iterate there. However, working with Vagrant and Docker makes this more complicated.\u003c/p\u003e\n\u003cp\u003eI wanted all this to work without having to rebuild Docker images, rerun docker containers, or reprovision Vagrant.\u003c/p\u003e\n\u003ch2 id=\"the-base-web-image\"\u003eThe Base Web Image\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-docker\"\u003e# baseweb Dockerfile\nFROM ubuntu:14.04\n\nENV DEBIAN_FRONTEND noninteractive\nRUN echo debconf shared/accepted-oracle-license-v1-1 select true | debconf-set-selections\nRUN echo debconf shared/accepted-oracle-license-v1-1 seen true | debconf-set-selections\n\nRUN apt-get update \u0026amp;\u0026amp; apt-get install -y software-properties-common\nRUN add-apt-repository ppa:webupd8team/java \u0026amp;\u0026amp; add-apt-repository ppa:chris-lea/node.js \u0026amp;\u0026amp; apt-get update\n\nRUN apt-get install -y git subversion g++ python libnss3-dev libasound2-dev libpulse-dev \\\nlibjpeg62-dev libxv-dev libgtk2.0-dev libexpat1-dev libxss-dev libudev-dev libdrm-dev libgconf2-dev \\\nlibgcrypt11-dev libpci-dev libxtst-dev libgnome-keyring-dev libssl-dev nodejs oracle-java6-installer oracle-java6-set-default\n\nENV JAVA_HOME /usr/lib/jvm/java-6-oracle/\nENV PATH $PATH:/usr/lib/jvm/java-6-oracle/jre/bin/\n\n\nRUN npm install -g forever\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith the \u003ccode\u003eBaseWeb\u003c/code\u003e Dockerfile inplace I then have my Nodejs application. It\u0026#39;s structured as follows.\u003c/p\u003e\n\u003ch2 id=\"the-web-application-code\"\u003eThe Web Application Code\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e/Projects/demo/web\n├── Dockerfile\n├── index.js\n├── node_modules -\u0026gt; /dist/node_modules/\n└── package.json\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTake note here that my \u003ccode\u003enode_modules\u003c/code\u003e is actually a symlink to \u003ccode\u003e/dist/node_modules/\u003c/code\u003e this is committed to my repo. This may seem odd but it\u0026#39;s key to letting us rapidly develop on a custom module. It enables a \u003ccode\u003enpm link\u003c/code\u003e style work flow.\u003c/p\u003e\n\u003ch3 id=\"the-vagrant-setup\"\u003eThe Vagrant Setup\u003c/h3\u003e\n\u003cp\u003eAssume we have a Vagrantfile outside of our web project like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e/Projects/demo/\n├── Vagrantfile\n└── web\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will automatically mount the web code as a shared directory inside the Vagrant machine at \u003ccode\u003e/vagrant/web\u003c/code\u003e. At this point we can \u003ccode\u003evagrant up\u003c/code\u003e and edit the application code on the host machine as usual and Vagrant will pickup the changes. This dosen\u0026#39;t help us yet because the code is dependent on the ismorphic WebRTC dependences. We need Vagrant to run the Docker containers.\u003c/p\u003e\n\u003cp\u003eBefore we get to the \u003ccode\u003eVagrantfile\u003c/code\u003e let\u0026#39;s look at the Web Applications\u0026#39; Dockerfile.\u003c/p\u003e\n\u003ch2 id=\"the-web-application-dockerfile\"\u003eThe Web Application Dockerfile\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-dockerfile\"\u003e# web DockerFile\nFROM base_web\nCOPY package.json /dist/package.json\nRUN mkdir /dist/node_modules \u0026amp;\u0026amp; cd /dist \u0026amp;\u0026amp; npm install\nADD . /srv/www\nRUN ln -s /dist/node_modules /srv/www/node_modules\nWORKDIR /srv/www\nEXPOSE 5000\nCMD [\u0026quot;forever\u0026quot;, \u0026quot;index.js\u0026quot;]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"points-of-interest\"\u003ePoints Of Interest\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eThe key to this whole thing here is the \u003ccode\u003enode_modules\u003c/code\u003e setup. We don\u0026#39;t do the \u003ccode\u003enpm install\u003c/code\u003e in the application code directory. We create a \u003ccode\u003e/dist/\u003c/code\u003e directory and copy \u003ccode\u003epackage.json\u003c/code\u003e there. We then \u003ccode\u003enpm install\u003c/code\u003e in \u003ccode\u003e/dist\u003c/code\u003e and get \u003ccode\u003e/dist/node_modules\u003c/code\u003e. This is really the seceret sauce. In production you don’t rebuild your modules each time you re-build your container. If your \u003ccode\u003epackage.json\u003c/code\u003e file changes then your modules will be rebuilt. I got this from  \u003ca href=\"http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/\"\u003eBuilding Efficient Dockerfiles\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eRUN ln -s /dist/node_modules /srv/www/node_modules\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e This creates a symlink for \u003ccode\u003enode_modues\u003c/code\u003e from our application code at \u003ccode\u003e/srv/www\u003c/code\u003e. to our \u003ccode\u003e/dist\u003c/code\u003e. This also overrides the symlink that is committed in the web repo. You might be thinking, \u0026quot;well what was the point of that then?\u0026quot;. I promise we\u0026#39;ll get to that soon. It\u0026#39;s key to the \u003ccode\u003enpm link\u003c/code\u003e style.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"the-vagrant-file\"\u003eThe Vagrant File\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003eVagrant.configure(2) do |config|\n  config.vm.box = \u0026quot;Ubuntu 14.04 with Docker enabled\u0026quot;\n  config.vm.box_url = \u0026quot;https://github.com/jose-lpa/packer-ubuntu_14.04/releases/download/v2.0/ubuntu-14.04.box\u0026quot;\n\n  config.vm.provision \u0026quot;docker\u0026quot; do |d|\n    d.build_image \u0026quot;/vagrant/Dockerfiles/base_web\u0026quot;, args: \u0026#39;-t \u0026quot;base_web\u0026quot;\u0026#39;\n    d.build_image \u0026quot;/vagrant/web\u0026quot;, args: \u0026#39;-t \u0026quot;web\u0026quot;\u0026#39;\n\n    d.run \u0026quot;web\u0026quot;,\n          cmd: \u0026quot;forever -w bin/server.js\u0026quot;,\n          args: \u0026quot;-v \u0026#39;/vagrant/web:/srv/www\u0026#39;\\\n                 -e NODE_ENV=development\\\n                 -p 5000:5000\u0026quot;\n  end\n\n  config.vm.network \u0026quot;forwarded_port\u0026quot;, guest: 5000, host: 5000\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"points-of-interest-1\"\u003ePoints of interest\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eWe use a \u0026#39;Docker enabled\u0026#39; image for our Docker box.\u003c/li\u003e\n\u003cli\u003eWe use Vagrant\u0026#39;s built-in Docker provisioner.\u003c/li\u003e\n\u003cli\u003eWe then run our container with some new arguments.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet\u0026#39;s look at the run command more in-depth.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e    d.run \u0026quot;web\u0026quot;,\n          cmd: \u0026quot;forever -w index.js\u0026quot;,\n          args: \u0026quot;-v \u0026#39;/vagrant/web:/srv/www\u0026#39;\\\n                 -e NODE_ENV=development\\\n                 -p 5000:5000\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe\u0026#39;re overriding the Dockerfiles\u0026#39; \u003ccode\u003eCMD [\u0026quot;forever\u0026quot;, \u0026quot;index.js\u0026quot;]\u003c/code\u003e with \u003ccode\u003eforever -w index.js\u003c/code\u003e The \u003ccode\u003e-w\u003c/code\u003e flag restarts our server on code updates, which is what we want in a development environment.\u003c/p\u003e\n\u003ch3 id=\"bringing-it-all-together\"\u003eBringing It All Together\u003c/h3\u003e\n\u003cp\u003eThe Most important part of the \u003ccode\u003edocker run\u003c/code\u003e options is the \u003ccode\u003e-v\u003c/code\u003e flag, which is for Docker Volumes. We are telling our container to mount \u003ccode\u003e/srv/www\u003c/code\u003e as a volume that points to \u003ccode\u003e/vagrant/web/\u003c/code\u003e. If you review our Vagrant setup from earlier you can see that \u003ccode\u003e/srv/www\u003c/code\u003e is actualy a shared directory to our application code directory \u003ccode\u003e/web\u003c/code\u003e on the host machine!\u003c/p\u003e\n\u003cp\u003eA quick diagram of this shared filesystem cascade looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eDocker `/srv/www` -\u0026gt;\nVagrant `/vagrant/web -\u0026gt;\nHost `/web`/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this point you\u0026#39;re set up to rapidly develop on your application code and have updates reflected in your Docker container.\u003c/p\u003e\n\u003cp\u003eThe next challenge I faced was figuring out how to handle a local NPM module dependency that I wanted to iterate on in the same rapid manner.\u003c/p\u003e\n\u003ch2 id=\"npm-link-development-in-a-docker-container\"\u003eNPM Link Development In A Docker Container\u003c/h2\u003e\n\u003cp\u003eSo in this scenario. Lets assume that \u003ccode\u003eweb\u003c/code\u003e has an entry in \u003ccode\u003epackage.json\u003c/code\u003e like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e  \u0026quot;dependencies\u0026quot;: {\n   \u0026quot;customModule\u0026quot;: \u0026quot;git://github.com/kevzettler/customModule\u0026quot;,\n   }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecustomModule\u003c/code\u003e is a NPM module that we maintain and develop. This package.json setup works fine for production because we just install from the repo and forget about it. In development we want to rapidly make changes to \u003ccode\u003ecustomModule\u003c/code\u003eand not have to rebuild everything. Normally when developing on local machine, we would \u003ccode\u003ecd\u003c/code\u003e into \u003ccode\u003eweb\u003c/code\u003e and do \u003ccode\u003enpm link customModule\u003c/code\u003e which would build a symlink to our \u003ccode\u003ecustomModule\u003c/code\u003e code that would give us a rapid development setup.\u003c/p\u003e\n\u003cp\u003eWhen we add Vagrant and Docker to the dev environment, this completly breaks NPM Link.\u003c/p\u003e\n\u003cp\u003eHere\u0026#39;s an updated directory diagram of our project with the new \u003ccode\u003ecustomModule\u003c/code\u003e code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e/Projects/demo/\n├── Vagrantfile\n├── web\n└── customModule\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo similliar to the web code, Vagrant will mount our customModule code at \u003ccode\u003e/vagrant/customModule\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe can then update our VagrantFile to add a new Docker Volume:\n\u003ccode\u003e-v \u0026#39;/vagrant/engine:/dist/node_modules/engine\u0026#39;\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003e    d.run \u0026quot;web\u0026quot;,\n          cmd: \u0026quot;forever -w index.js\u0026quot;,\n          args: \u0026quot;-v \u0026#39;/vagrant/web:/srv/www\u0026#39;\\\n                 -v \u0026#39;/vagrant/customModule:/dist/node_modules/customModule\u0026#39;\\\n                 -e NODE_ENV=development\\\n                 -p 5000:5000\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"whats-all-this-symlink-business-then\"\u003eWhat\u0026#39;s All This Symlink Business Then?\u003c/h3\u003e\n\u003cp\u003eSo we have this symlink in 2 places.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eThe \u003ccode\u003eRUN\u003c/code\u003e symlink in Web Dockerfile\n  \u003ccode\u003eRUN ln -s /dist/node_modules /srv/www/node_modules\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIn \u0026#39;Filesystem\u0026#39; symlink\n  \u003ccode\u003enode_modules -\u0026gt; /dist/node_modules/\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDocker does not support symlinks when using the \u003ccode\u003eADD\u003c/code\u003e command in a DockerFile.\nIt will drop them from the \u003ccode\u003eADD\u003c/code\u003e filesystem. That\u0026#39;s why we need the \u003ccode\u003eRUN\u003c/code\u003e symlink in the dockerfile.\u003c/p\u003e\n\u003cp\u003eWhen we want to do development work, we run the container with the \u003ccode\u003e-v\u003c/code\u003e flag to mount our local code. The volume doesn\u0026#39;t get attached until after our container has already been created. At that time, the \u003ccode\u003eRUN\u003c/code\u003e symlink exists; however, the \u003ccode\u003e-v\u003c/code\u003e option overrides everything in the container\u0026#39;s \u003ccode\u003e/srv/www/\u003c/code\u003e, wiping out the \u003ccode\u003eRUN\u003c/code\u003e symlink.\u003c/p\u003e\n\u003cp\u003eBut wait! We have a \u0026#39;Filesystem\u0026#39; symlink in our shared code. The volume respects this symlink and it routes internally to the container\u0026#39;s filesystem. You don\u0026#39;t necessarily have to commit the symlink to your repo like I was dong. You just need it around when you build the Docker image. I committed it because I kept forgetting. Try this out and let me know if you have a better solution to it.\u003c/p\u003e\n","excerpt":"TLDR\n\nUsing a cascade of Vagrant shared directories, Docker volumes and cleverly placed symlinks, you can rig Vagrant and Docker to instantly reflect your local application code updates.\nDocker volume -\u003e Vagrant shared directory -\u003e Host machine code.\nEnable NPM link style development in Docker container.\nDosen't cover gulp","slug":"2015/06/07/rapid_local_development_vagrant_docker_node","meta":{"title":"Rapid Local Development with Vagrant, Docker and Node.js - Kev Zettler","keywords":["JavaScript","Conventions","Docker","Vagrant","Node.js"],"image":"img/kev.jpeg","description":"TLDR\n\nUsing a cascade of Vagrant shared directories, Docker volumes and cleverly placed symlinks, you can rig Vagrant and Docker to instantly reflect your local application code updates.\nDocker volume -\u0026gt; Vagrant shared directory -\u0026gt; Host machine code.\nEnable NPM link style development in Docker"}}},"__N_SSG":true},"page":"/[year]/[month]/[day]/[slug]","query":{"year":"2015","month":"06","day":"07","slug":"rapid_local_development_vagrant_docker_node"},"buildId":"4DEA3N0-2m_VOpUDOWqKG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>