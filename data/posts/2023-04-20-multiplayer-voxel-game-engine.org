#+TITLE: I built a multiplayer voxel browser game engine.
#+TAGS: gamedev, javascript, react

** Intro & TLDR;

  This post is a retrospective on a [[https://github.com/kevzettler/multiplayer-voxel-browser-game-engine][multiplayer voxel browser game engine]] I built. This post will cover the squishy storytelling side of the project and the [[https://github.com/kevzettler/multiplayer-voxel-browser-game-engine][accompanying code repository]] has all of the hard technical details.

*** Disclaimer

  This project is a bit old and stale at the time of this post. Some of the tech decisions made sense at during time of development but are questionable today. I will try to address that in this post. I started this project with very minimal game development experience. I had no idea how many things worked, shaders, 3d asset files, raw binary buffer manipulation, physics engines. I learned all these skills and more during this project. This experience also helped me later land some major corporate jobs. This project was primarily active through 2017-2019 however exploration for the project goes back to late 2016.

#+BEGIN_HTML
<a href='/img/multiplayer-engine-post/disclaimer.png'>
  <img src='/img/multiplayer-engine-post/disclaimer.png'
       alt="Should you build a custom engine? Yes."
       title="Should you build a custom engine? Yes" width="400" />
</a>
#+END_HTML

** Inspiration & motivation

  I wanted to build a multiplayer browser game. I was very inspired by .io games and sites like [[https://iogames.space/][iogames.space]]. I love the .io gaming experience of copy pasting a URL around and getting in a game with your friends. Furthermore I wanted to recreate a canceled MMO called [[https://en.wikipedia.org/wiki/Exteel][Exteel]]. My background was in web development and design. I stuck with the tools and environment I was most familiar with.

*** Target features
  + network multiplayer
  + playable cross platform in browser
  + player avatar customization
  + lazy loading assets
  + shared client & server game code
  + third person camera
  + platforming physics
  + destructible environments

All these features were completed except for destructible environments. Destructible environments was a big driver for the voxel asset pipeline, assuming voxels would enable the destructibility. This idea was inspired by another browser game [[https://github.com/Lallassu/VoxLords][VoxLords]] which had captured my imagination. I actually started this out by forking and modifying VoxLords to be multiplayer.

https://twitter.com/lallassu/status/725401257377169409?s=20

After hacking on VoxLords it was clear that it was entirely possible to make a captivating 3D multiplayer browser experience. Unfortunately, Lallassu was correct and there were some major performance issues in the VoxLords engine that would require extensive refactoring. I decided to start a fresh project.

** The work
After hacking the VoxLords multiplayer fork. I started by exploring multiple tech stacks concurrently and building a prototype in each of them. The stacks I looked at were Babylon.js, three.js, & stackgl.

*** Tech stack requirements

  The first requirement was support for the 3d asset pipeline. I had been working with voxel models in [[https://ephtracy.github.io/][MagicaVoxel .vox]] format. This was great for static entities. There's primarily 2 ways to animate a voxel model. You can create frame based animation, in which you each frame of the animation is a separate voxel animation and then you morph or swap them out on at runtime. Or you can apply skeletal transformation data to voxel meshes. If you decide on the skeletal route you need to break the voxel mesh up into smaller mesh's that correspond to the skeleton bones.

I had a character mesh that I wanted to use in .vox format but at the time MagicaVoxel did not support multiple meshes. I converted the .vox file to [[https://www.getqubicle.com/][quiblce .qb]] file and broke the character up into separate meshes.

#+BEGIN_HTML
<a href='/img/multiplayer-engine-post/qubicle.png'>
  <img src='/img/multiplayer-engine-post/qubicle.png'
       alt="Qubicle UI breaking a mesh up"
       title="Using Qubicle to break up a mesh for skeletal animation"/>
</a>
#+END_HTML

The segmented qubicle mesh was then imported into Blender and animations were built in blender.

#+BEGIN_HTML
<a href='/img/multiplayer-engine-post/blender.gif'>
  <img src='/img/multiplayer-engine-post/blender.gif'
       alt="Blender skeletal walking animation"
       title="voxel model animated in blender with skeletal animation"/>
</a>
#+END_HTML

The animation data and voxel meshes data was combined at runtime in the engine.


*** Tech stack evaluation

+ [[https://threejs.org/][three.js]]

  VoxLords was built in Three.js so I looked at it first. The Three.js - Blender pipeline was broken and could not get skeletal animation imports working. A colleague of mine who was working on a Three.js project captured some of the [[https://gist.github.com/AndrewRayCode/746be166c3008a03167206aec4a46531][ three.js blender exporter issues]] at the time. This was a deal breaker for me.

  Furthermore, Three.js did not have a good headless server side offering. Three.js uses custom math libraries that were not easily extract-able from the rendering code. This meant multiplayer support would take a lot of extra duplicate work, re-implementing the game logic on the server. Three.js has advanced significantly since then, I don't think these are issues anymore.


+ [[https://www.babylonjs.com/][babylon.js]]

  I made some immediate promising progress in Babylon.js. The asset pipeline was robust and supported skeletal animation data. Babylon has camera and physics out of the box. The Babylon team and  community was super responsive and supportive. I hit a wall with Babylon.js when trying to build out the multiplayer server. Like Three.js, Babylon.js had no headless mode. Again, this meant that building multiplayer would require duplicate work reproducing all the simulation logic and physics in the server side codebase. Recent versions of Babylon have a robust headless mode and have decoupled the framework into smaller libraries. These days Three.js is king of the normie browser 3d mind share lexicon but I still find Babylon.js a much better offering.


+ [[http://stack.gl/][stackgl]]

  Stackgl is the dark-horse of this list. Stackgl is not trying to be a complete 3D engine like Three.js and Babylon.js. Stackgl is an ecosystem of small functional tools that can be composed to create 3d browser experiences. Stackgl follows the unix philosophy of "small sharp tools". Stackgl has some main pillars: Rendering, Math, and Data. Stackgl handles rendering by focusing on direct shader code. Babylon.js and Three.js try to heavily abstract shaders away. Stackgl's primary rendering module is [[http://regl.party/][Regl]] which provides a completely novel stateless rendering pattern. Stackgl then provides many small functional math modules for dealing with vertex and geometry data. I was quickly more productive in Stackgl than the previous two stacks. The modular nature made it very easy to share code between the client and server, easy to optimize performance and rendering, and easy to add custom functionality.

  #+BEGIN_HTML
<a href='/img/multiplayer-engine-post/engines.png'>
  <img src='/img/multiplayer-engine-post/engines.png'
       alt="Screenshotf of github showing multiple game engines"
       title="Which 3d browser engine is best?" />
</a>
#+END_HTML

When I started making progress with Stackgl I took a year off and worked on it full time throughout 2017.

** What went wrong

**** React vs Vanilla Js

Most my web development experience has been with the React framework and I thought it would be complementary to Regl and the stack.gl ecosystem's functional paradigm. I created a [[https://github.com/kevzettler/react-regl][react reconciler to bridge react and regl]]. I started using a React stack with Redux to manage all the game state and state transitions. This React+Redux combo turned out to be a huge boon when writing UI. Game developers in traditional engines constantly complain about UI being their least favorite task. This is because game engines use traditional 2-way mutable state management UI code that is error prone and brittle. Web developers have solved these UI complaints and built tools like React that make building UI's easy.

**** Hobby time
When I started making progress with Stackgl I took a year off and worked on it full time throughout 2017.

**** Software entropy
Severe software entropy. In 2019 I upgraded my laptop to an M1 Mac. This triggered a roadblock on the project because the WebRTC module I was using would not compile on the new M1 apple silicon chip.
The animation pipeline using Landon had severe entropy

** Byproducts
The work put into this project spun-off some useful open-source libraries

+ [[https://github.com/kevzettler/react-regl][react-regl]]

  A react reconciler to bridge react and regl

+ [[https://github.com/kevzettler/parse-magica-voxel][parse-magica-voxel]]

  A JavaScript parser for the magicavoxel .vox binary file format

+ [[https://github.com/kevzettler/parse-qubicle][parse-quibicle]]

  A JavaScript parser for the .qb binary file format.


** Shout outs

  This project was built on the work and research of other highly skilled software engineers. Its worth mentioning their work

+ [[https://twitter.com/MikolaLysenko][Mikola lysenko]]

  Mikola is a primary driver of the stack.gl ecosystem and certified 10x genius developer. His blog [[https://0fps.net][0fps.net]] has some mind melting content on high performance computer science, and geometry. Mikola assembled a team and basically built a Roblox clone for China in the browser.  [[https://www.youtube.com/watch?v=Z_--8z549D4][Reflections on building web-based voxel MMO in China (Mikola Lysenko, et al) - YouTube]]

+ [[https://chinedufn.com/][Chinedu Francis Nwafili]]

   Chinedu did amazing work by building the [[https://github.com/chinedufn/skeletal-animation-system][stackgl skeletal animation system]] which a key piece of the stack.gl ecosystem and this project was highly dependent on and probably couldn't have come together without. While I was building out this project Chinedu was also building out his own game and engine we kept in correspondence while building and sharing ideas. Chinedu also built out a very cool suite of tools for Blender called [[https://github.com/chinedufn/landon][landon]]. Making Blender a source of truth for game engine data. Chinedu's blog at https://chinedufn.com/ has in-depth development journal posts on his game engine development.


** The state of the art
  I'm writing this post to put closure on the project before moving on new work.


+ [[https://github.com/matrix-org/thirdroom#manifold-engine][Manifold engine]]

  The manifold engine


+ [[https://dotbigbang.com/][DotBigBang]]

  DotBigBang is a

+ [[https://github.com/AmbientRun/Ambient][Ambient engine]]

  Ambient is a new Rust lang engine
