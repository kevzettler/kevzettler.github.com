#+TITLE: I built a multiplayer voxel browser game engine.
#+IMAGE: img/multilpayer-engine-post/meta.png
#+TAGS: gamedev, javascript, react

** Intro & TLDR;

  This post is a retrospective on a [[https://github.com/kevzettler/multiplayer-voxel-browser-game-engine][multiplayer voxel browser game engine]] I built. This post will cover the squishy storytelling side of the project and the [[https://github.com/kevzettler/multiplayer-voxel-browser-game-engine][accompanying code repository]] has all of the hard technical details. This is essentially a 2 part post. Read this and read the repo README.

    #+BEGIN_HTML
<a href='/img/multiplayer-engine-post/play.gif'>
  <img src='/img/multiplayer-engine-post/play.gif'
       alt="Animated give of a 3d multiplayer browser engine"
       title="Demonstartion of multiplayer game engine multilpe players" />
</a>
#+END_HTML


*** Disclaimer

  This project is a bit old and stale at the time of this post. Some of the tech decisions made sense at during time of development but are questionable today. I will try to address that in this post. I started this project with very minimal game development experience. I had no idea how many things worked, shaders, 3d asset files, raw binary buffer manipulation, scene graphs, physics engines. I learned all these skills and more during this project. This experience also helped me later land some major corporate jobs. This project was primarily active through 2017-2019 however exploration for the project goes back to late 2016.

#+BEGIN_HTML
<a href='/img/multiplayer-engine-post/disclaimer.png'>
  <img src='/img/multiplayer-engine-post/disclaimer.png'
       alt="Should you build a custom engine? Yes."
       title="Should you build a custom engine? Yes" width="400" />
</a>
#+END_HTML

** Inspiration & motivation

  I wanted to build a multiplayer browser game. I was very inspired by ~.io~ games and sites like [[https://iogames.space/][iogames.space]]. I love the ~.io~ gaming experience of copy pasting a URL around and getting in a game with your friends. Furthermore I wanted to recreate a canceled MMO called [[https://en.wikipedia.org/wiki/Exteel][Exteel]]. My background was in web development and design. I stuck with the tools and environment I was most familiar with.

*** Target features
  + network multiplayer
  + playable cross platform in browser
  + player avatar customization
  + lazy loading assets
  + shared client & server game code
  + third person camera
  + platforming physics
  + destructible environments

All these features were completed except for destructible environments. Destructible environments was a big driver for the voxel asset pipeline, assuming voxels would enable the destructibility. This idea was inspired by another browser game [[https://github.com/Lallassu/VoxLords][VoxLords]] which had good environmental destruction and captured my imagination. I actually started this out by forking and modifying VoxLords to be multiplayer.

https://twitter.com/lallassu/status/725401257377169409?s=20

After hacking on VoxLords it was clear that it was entirely possible to make a captivating 3D multiplayer browser experience. Unfortunately, Lallassu was correct and there were some major performance issues in the VoxLords engine that would require extensive refactoring. I decided to start a fresh project.

**** Why I didn't use one of the mega corp engines

  I was not happy with Unity and Unreal's HTML5 browser experience. Unity's HTML5 export creates a giant asset bundle that users have to sit and watch a loading bar before playing. This was against my goals of lazy loading assets on demand. Additionally Unity's multiplayer server side support was sketchy and [[https://radcade.com/unity-multiplayer-netcode-for-gameobjects/][still is]]. Unreal had much stronger multiplayer support but similar issues with browser builds and in addition Unreal itself was too large to install on my laptop.

** The work

  After hacking the VoxLords multiplayer fork. I started by exploring multiple tech stacks concurrently and building a prototype in each of them. The stacks I looked at were Babylon.js, three.js, & Stackgl.

*** Tech stack requirements

  The first requirement was support for the 3d asset pipeline. I had been working with voxel models in [[https://ephtracy.github.io/][MagicaVoxel .vox]] format. This was great for static entities. There's primarily 2 ways to animate a voxel model. You can create frame based animation, in which you each frame of the animation is a separate voxel animation and then you morph or swap them out on at runtime. Or you can apply skeletal transformation data to voxel meshes. If you decide on the skeletal route you need to break the voxel mesh up into smaller mesh's that correspond to the skeleton bones.

I had a character mesh that I wanted to use in .vox format but at the time MagicaVoxel did not support multiple meshes. I converted the .vox file to [[https://www.getqubicle.com/][quiblce .qb]] file and broke the character up into separate meshes.

#+BEGIN_HTML
<a href='/img/multiplayer-engine-post/qubicle.png'>
  <img src='/img/multiplayer-engine-post/qubicle.png'
       alt="Qubicle UI breaking a mesh up"
       title="Using Qubicle to break up a mesh for skeletal animation"/>
</a>
#+END_HTML

The segmented qubicle mesh was then imported into Blender and animations were built in blender.

#+BEGIN_HTML
<a href='/img/multiplayer-engine-post/blender.gif'>
  <img src='/img/multiplayer-engine-post/blender.gif'
       alt="Blender skeletal walking animation"
       title="voxel model animated in blender with skeletal animation"/>
</a>
#+END_HTML

The animation data and voxel meshes data was combined at runtime in the engine.

https://twitter.com/kevzettler/status/1002235365246222336?s=20


*** Tech stack evaluation

+ [[https://threejs.org/][three.js]]

  VoxLords was built in Three.js so I looked at it first. The Three.js - Blender pipeline was broken and could not get skeletal animation imports working. A colleague of mine who was working on a Three.js project captured some of the [[https://gist.github.com/AndrewRayCode/746be166c3008a03167206aec4a46531][ three.js blender exporter issues]] at the time. This was a deal breaker for me.

  Furthermore, Three.js did not have a good headless server side offering. Three.js uses custom math libraries that were not easily extract-able from the rendering code. This meant multiplayer support would take a lot of extra duplicate work, re-implementing the game logic on the server. Three.js has advanced significantly since then, I don't think these are issues anymore.


+ [[https://www.babylonjs.com/][babylon.js]]

  I made some immediate promising progress in Babylon.js. The asset pipeline was robust and supported skeletal animation data. Babylon has camera and physics out of the box. The Babylon team and  community was super responsive and supportive. I hit a wall with Babylon.js when trying to build out the multiplayer server. Like Three.js, Babylon.js had no headless mode. Again, this meant that building multiplayer would require duplicate work reproducing all the simulation logic and physics in the server side codebase. Recent versions of Babylon have a robust headless mode and have decoupled the framework into smaller libraries. These days Three.js is king of the normie browser 3d mind share lexicon but I still find Babylon.js a much better offering.


+ [[http://stack.gl/][stackgl]]

  Stackgl is the dark-horse of this list. Stackgl is not trying to be a complete 3D engine like Three.js and Babylon.js. Stackgl is an ecosystem of small functional tools that can be composed to create 3d browser experiences. Stackgl follows the unix philosophy of "small sharp tools". Stackgl has some main pillars: Rendering, Math, and Data. Stackgl handles rendering by focusing on direct shader code. Babylon.js and Three.js try to heavily abstract shaders away. Stackgl's primary rendering module is [[http://regl.party/][Regl]] which provides a completely novel stateless rendering pattern. Stackgl then provides many small functional math modules for dealing with vertex and geometry data. I was quickly more productive in Stackgl than the previous two stacks. The modular nature made it very easy to share code between the client and server, easy to optimize performance and rendering, and easy to add custom functionality.

  #+BEGIN_HTML
<a href='/img/multiplayer-engine-post/engines.png'>
  <img src='/img/multiplayer-engine-post/engines.png'
       alt="Screenshotf of github showing multiple game engines"
       title="Which 3d browser engine is best?" />
</a>
#+END_HTML

*When I started making progress with Stackgl I took a year off and worked on it full time throughout 2017.*

** What went wrong

  Unfortunately, I consider this project unfinished. I did not ship a complete game experience and there are some issues with the engine that would be risky for production deployment. I'm writing this post to put closure on the project before moving on to new work and in the hopes that this experience may be useful to any others interested in this space.

**** React vs Vanilla Js

  Most my web development experience has been with the React framework and I thought it would be complementary to Regl and the stack.gl ecosystem's functional paradigm. I created a [[https://github.com/kevzettler/react-regl][react reconciler to bridge react and regl]]. I started using a React stack with Redux to manage all the game state and state transitions. This React+Redux combo turned out to be a huge boon when writing UI. Game developers in traditional engines constantly complain about UI being their least favorite task. This is because game engines use traditional 2-way mutable state management UI code that is error prone and brittle. Web developers have solved these UI complaints and built tools like React that make building UI's easy.

  #+BEGIN_HTML
<a href='/img/multiplayer-engine-post/react.gif'>
  <img src='/img/multiplayer-engine-post/react.gif'
       alt="animated gif of a React 3d browser UI"
       title="React 3d player avatar creation system" width="400" />
</a>
#+END_HTML

React+Redux setup was too much performance overhead for the real time game play section. The state updates through the Redux action reducer pipeline, combined with the minimal React render updates was enough to cause noticeable hiccups in the game play frame rate. Performance in the browser environment is very sensitive to garbage collector management. In order to minimize garbage collector hits you need to use object pooling. Object pooling is a mutable state management pattern in which you pre-allocate a pool of objects that will be mutated during the life of the program to minimize runtime memory allocations. This object pooling pattern conflicts with the immutable update patterns React and Redux are built upon. Hitting these performance issues was a big roadblock and essentially became a 'rewrite' in which had to rewrite the game state management to be performance optimized. This was costly and took a lot of time.

**** Hobby time

  When I started making progress with Stackgl I took a year off and worked on it full time throughout 2017. I lived off some savings and unemployment checks until late 2018 I got back into corporate wage slavery from 2018-2020. A highlight during this time was I got invited to Animecon 2019 indie developer section to shill my game in the Indie game section.

  #+BEGIN_HTML
<a href='/img/multiplayer-engine-post/animecon.png'>
  <img src='/img/multiplayer-engine-post/animecon.png'
       alt="A photo of me at animecon 2019 "
       title="Playing a game with a 2B cosplayer at animecon 2019" />
</a>
#+END_HTML

During this time I switched to hobby mode started putting less and less time into development I was maybe averaging 4 hours a week. I was distracted by day job work. This time shortage slowed development progress. Development picked up during 2020 Covid lockdowns unfortunately getting back into development after a hiatus presented some new challenges...

***** Software entropy
  The JavaScript ecosystem is known for moving incredibly fast. When I got back into development I spent a lot of time fighting severe software entropy. Getting the project to build with latest dependency chains of Node+NPM+webpack etc took a lot of work. The animation pipeline using Landon had severe entropy. The Landon was a mix of Rust, JavaScript and Blender versions that were not strictly pinned. I had to do work to upgrade to the latest Blender export versions but then write backwards compatibility translation layers for the animation data. I upgraded my laptop to an M1 Mac. This triggered a roadblock on the project because the WebRTC module I was using would not compile on the new M1 apple silicon chip. This has since been resolved but was pretty much the show stopper.

** Byproducts

  The work put into this project spun-off some useful libraries that I have open sourced and put on github

+ [[https://github.com/kevzettler/react-regl][react-regl]]

  A react reconciler to bridge react and regl

+ [[https://github.com/kevzettler/parse-magica-voxel][parse-magica-voxel]]

  A JavaScript parser for the magicavoxel .vox binary file format

+ [[https://github.com/kevzettler/parse-qubicle][parse-quibicle]]

  A JavaScript parser for the .qb binary file format.

+ [[https://github.com/kevzettler/gl-swept-sphere-triangle][gl-swept-sphere-triangle]]

  A swept sphere to polygon collision detection algorithm

** Shout outs

  This project was built on the work and research of other highly skilled software engineers. Without their help

+ [[https://twitter.com/MikolaLysenko][Mikola lysenko]]

  Mikola is a primary driver of the stack.gl ecosystem and certified 10x genius developer. His blog [[https://0fps.net][0fps.net]] has some mind melting content on high performance computer science, and geometry. Mikola assembled a team and basically built a Roblox clone for China in the browser. The team got together for a podcast to discuss their [[https://www.youtube.com/watch?v=Z_--8z549D4][Reflections on building web-based voxel MMO in China (Mikola Lysenko, et al) - YouTube]]  It is a highly insighful talk, highly recommend if you found this post interesting.

+ [[https://chinedufn.com/][Chinedu Francis Nwafili]]

   Chinedu did amazing work by building the [[https://github.com/chinedufn/skeletal-animation-system][stackgl skeletal animation system]] which is a key piece of the stack.gl ecosystem and this project was highly dependent on and probably couldn't have come together without. While I was building out this project Chinedu was also building out his own game and engine we kept in correspondence while building and sharing ideas. Chinedu also built out a very cool suite of tools for Blender called [[https://github.com/chinedufn/landon][landon]]. Making Blender a source of truth for game engine data. Chinedu's blog at https://chinedufn.com/ has in-depth development journal posts on his game engine development.

+ [[http://www.jameswarlloyd.com/][James Warlloyd]]

  James created the [[https://opengameart.org/content/voxel-mech-sniper][original mech model]] that I used as the bases for the character art in this engine.



** The state of the art

  Overall this project was a big educational return on investment for me. I learned about hardcore browser optimization and many other data processing techniques. I have continued to do game ( and engine ) development as a hobby and have already looked into some other emerging technologies. My focus is still on browser multiplayer experiences. I haven't found the big engines: Unreal, Unity, Godot have the best models for multiplayer. I have previously written about [[https://radcade.com/how-to-add-network-multiplayer-to-your-indie-game/][multilpayer game engine design for indies]]. The big engines have models that couple game simulation logic code to rendering code. This makes it challenging to build a server as you have to decouple the simulation and run it headless.

+ [[https://dotbigbang.com/][DotBigBang]]

  DotBigBang is everything this project attempted to be and more. It is multiplayer voxel 3d engine all fully in the browser. DotBigBang is focused on user generated content and is essentially a multiplayer game engine. You can get a group of people together and bring your avatars into a 3D scene and then collaboratively edit and program that scene. Like a multiplayer Unity editor experience. I had the fortune to hang with the founder of DotBigBang at GDC 2023 and hear about some of the impressive browser performance optimization they were doing. He told me about forking Chromium to have better performance debugging visibility into how the JIT compilation and memory usage of the browser was working.

+ [[https://github.com/matrix-org/thirdroom#manifold-engine][Manifold engine]]

  The Manifold engine is a stealthy engine being developed by the [[https://matrix.org/][matrix.org]] team. Its currently embedded in a repository for another project with a disclaimer they might release it in the future. The host project is called 'thirdroom' and is a multilpayer VR metaverse platform.

  When I learned about Manifold I was very excited because it has the same design philosophy and high performance computation architecture that I had been building towards. It uses Web Workers to create multiple threads to separately process rendering, physics, and networking. All the threads share memory over a [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer][SharedArrayBuffer]] and they use object pooling to reduce garbage collection. Manifold also has WebRTC Data channels for networking. I was able to build a promising prototype in Manifold unfortunately Manifold is tightly coupled to a matrix.org backend. The matrix backend has a clunky API to use which would make custom server side optimization challenging. If the matrix.org team ever decouples and delivers Manifold it would be very compelling option.

+ [[https://github.com/AmbientRun/Ambient][Ambient engine]]

  Ambient is a promising new Rust lang engine. It is a default multiplayer engine. It shares code between client and server. It compiles game code to WASM and then acts as a cross platform binary runtime to execute that WASM. I have built a promising prototype in Ambient but unfortunately Ambient does not currently build for browser environments. The Ambient team is actively working to target browsers and are aiming for an upcoming release.
